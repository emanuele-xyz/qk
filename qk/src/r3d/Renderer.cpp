#include <qk/PCH.h>
#include <qk/r3d/Renderer.h>
#include <qk/r3d/Mesh.h>
#include <qk/r3d/Texture.h>
#include <qk/D11.h>

// constant buffers definitions
#define int std::int32_t
#define matrix Matrix
#define float3 Vector3
#include <qk/hlsl/ObjectPassBuffers.h>
#undef float3
#undef matrix
#undef int

#include <DirectXTex.h>

namespace qk::r3d
{
    constexpr DXGI_FORMAT MESH_INDEX_FORMAT{ DXGI_FORMAT_R32_UINT };
    static_assert(sizeof(MeshIndex) == 4);

    static D3D11_FILTER GetD3D11FilterFromSamplerFilter(SamplerFilter filter)
    {
        D3D11_FILTER out{};
        switch (filter)
        {
        case SamplerFilter::Nearest: { out = D3D11_FILTER_MIN_MAG_MIP_POINT; } break;
        case SamplerFilter::Linear: { out = D3D11_FILTER_MIN_MAG_MIP_LINEAR; } break;
        case SamplerFilter::Anisotropic: { out = D3D11_FILTER_ANISOTROPIC; } break;
        default: { qk_Unreachable(); } break;
        }
        return out;
    }
    static D3D11_TEXTURE_ADDRESS_MODE GetD3D11TextureAddressModeFromSamplerAddressMode(SamplerAddressMode mode)
    {
        D3D11_TEXTURE_ADDRESS_MODE out{};
        switch (mode)
        {
        case SamplerAddressMode::Wrap: { out = D3D11_TEXTURE_ADDRESS_WRAP; } break;
        case SamplerAddressMode::Mirror: { out = D3D11_TEXTURE_ADDRESS_MIRROR; } break;
        case SamplerAddressMode::Clamp: { out = D3D11_TEXTURE_ADDRESS_CLAMP; } break;
        case SamplerAddressMode::MirrorOnce: { out = D3D11_TEXTURE_ADDRESS_MIRROR_ONCE; } break;
        default: { qk_Unreachable(); } break;
        }
        return out;
    }
    static D3D11_SAMPLER_DESC GetD3D11SamplerDescFromSampler(const Sampler& sampler)
    {
        D3D11_SAMPLER_DESC desc{};
        desc.Filter = GetD3D11FilterFromSamplerFilter(sampler.filter);
        desc.AddressU = GetD3D11TextureAddressModeFromSamplerAddressMode(sampler.address_mode_u);
        desc.AddressV = GetD3D11TextureAddressModeFromSamplerAddressMode(sampler.address_mode_v);
        desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP; // NOTE: needed to not crash
        desc.MipLODBias = 0.0f;
        if (sampler.filter == SamplerFilter::Anisotropic)
        {
            desc.MaxAnisotropy = sampler.anisotropy;
        }
        //desc.ComparisonFunc = ;
        //desc.BorderColor = ;
        desc.MinLOD = 0.0f;
        desc.MaxLOD = D3D11_FLOAT32_MAX;
        return desc;
    }

    class Mesh
    {
    public:
        static Mesh Cube(ID3D11Device* dev);
        static Mesh Quad(ID3D11Device* dev);
        static Mesh Icosphere(ID3D11Device* dev);
        static Mesh Cone(ID3D11Device* dev);
        static Mesh ConeNoBase(ID3D11Device* dev);
    public:
        Mesh(ID3D11Device* dev, std::span<const MeshVertex> vertices, std::span<const MeshIndex> indices);
        ~Mesh() = default;
        Mesh(const Mesh&) = delete;
        Mesh(Mesh&&) noexcept = default;
        Mesh& operator=(const Mesh&) = delete;
        Mesh& operator=(Mesh&&) noexcept = default;
    public:
        ID3D11Buffer* Vertices() const noexcept { return m_vertices.Get(); }
        ID3D11Buffer* Indices() const noexcept { return m_indices.Get(); }
        UINT VertexCount() const noexcept { return m_vertex_count; }
        UINT IndexCount() const noexcept { return m_index_count; }
    private:
        wrl::ComPtr<ID3D11Buffer> m_vertices;
        wrl::ComPtr<ID3D11Buffer> m_indices;
        UINT m_vertex_count;
        UINT m_index_count;
    };
    Mesh Mesh::Cube(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
            // front face (Z+)
            { { -0.5f, -0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f } },

            // back face (Z-)
            { { +0.5f, -0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 0.0f, 1.0f } },
            { { -0.5f, -0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 1.0f, 1.0f } },
            { { -0.5f, +0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 1.0f, 0.0f } },
            { { +0.5f, +0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 0.0f, 0.0f } },

            // left face (X-)
            { { -0.5f, -0.5f, -0.5f }, { -1.0f, 0.0f, 0.0f }, { 0.0f, 1.0f } },
            { { -0.5f, -0.5f, +0.5f }, { -1.0f, 0.0f, 0.0f }, { 1.0f, 1.0f } },
            { { -0.5f, +0.5f, +0.5f }, { -1.0f, 0.0f, 0.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, -0.5f }, { -1.0f, 0.0f, 0.0f }, { 0.0f, 0.0f } },

            // right face (X+)
            { { +0.5f, -0.5f, +0.5f }, { +1.0f, 0.0f, 0.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, -0.5f }, { +1.0f, 0.0f, 0.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, -0.5f }, { +1.0f, 0.0f, 0.0f }, { 1.0f, 0.0f } },
            { { +0.5f, +0.5f, +0.5f }, { +1.0f, 0.0f, 0.0f }, { 0.0f, 0.0f } },

            // top face (Y+)
            { { -0.5f, +0.5f, +0.5f }, { 0.0f, +1.0f, 0.0f }, { 0.0f, 1.0f } },
            { { +0.5f, +0.5f, +0.5f }, { 0.0f, +1.0f, 0.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, -0.5f }, { 0.0f, +1.0f, 0.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, -0.5f }, { 0.0f, +1.0f, 0.0f }, { 0.0f, 0.0f } },

            // bottom face (Y-)
            { { -0.5f, -0.5f, -0.5f }, { 0.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, -0.5f }, { 0.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } },
            { { +0.5f, -0.5f, +0.5f }, { 0.0f, -1.0f, 0.0f }, { 1.0f, 0.0f } },
            { { -0.5f, -0.5f, +0.5f }, { 0.0f, -1.0f, 0.0f }, { 0.0f, 0.0f } },
        };

        MeshIndex indices[]
        {
            // front
            0, 1, 2,
            0, 2, 3,

            // back
            4, 5, 6,
            4, 6, 7,

            // left
            8, 9,10,
            8,10,11,

            // right
            12,13,14,
            12,14,15,

            // top 
            16,17,18,
            16,18,19,

            // bottom
            20,21,22,
            20,22,23
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::Quad(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
            { { -0.5f, -0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f } },
        };

        MeshIndex indices[]
        {
            0, 1, 2,
            0, 2, 3,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::Icosphere(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.181819f , 0.000000f } },
        { { 0.101590f, -0.483975f, 0.073809f }, { 0.211000f, -0.965400f, 0.153300f }, { 0.204546f , 0.039365f } },
        { { -0.038803f, -0.483975f, 0.119426f }, { -0.080600f, -0.965400f, 0.248000f }, { 0.159092f , 0.039365f } },
        { { 0.361804f, -0.223610f, 0.262863f }, { 0.723600f, -0.447200f, 0.525700f }, { 0.272728f , 0.157461f } },
        { { 0.304773f, -0.328759f, 0.221428f }, { 0.604200f, -0.665000f, 0.439000f }, { 0.295455f , 0.118096f } },
        { { 0.406365f, -0.251150f, 0.147619f }, { 0.815200f, -0.503800f, 0.285700f }, { 0.318182f , 0.157461f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.909091f , 0.000000f } },
        { { -0.038803f, -0.483975f, 0.119426f }, { -0.080600f, -0.965400f, 0.248000f }, { 0.931818f , 0.039365f } },
        { { -0.125573f, -0.483974f, 0.000000f }, { -0.260800f, -0.965400f, -0.000000f }, { 0.886364f , 0.039365f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.727273f , 0.000000f } },
        { { -0.125573f, -0.483974f, 0.000000f }, { -0.260800f, -0.965400f, -0.000000f }, { 0.750000f , 0.039365f } },
        { { -0.038803f, -0.483975f, -0.119426f }, { -0.080600f, -0.965400f, -0.248000f }, { 0.704546f , 0.039365f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.545455f , 0.000000f } },
        { { -0.038803f, -0.483975f, -0.119426f }, { -0.080600f, -0.965400f, -0.248000f }, { 0.568182f , 0.039365f } },
        { { 0.101590f, -0.483975f, -0.073809f }, { 0.211000f, -0.965400f, -0.153300f }, { 0.522728f , 0.039365f } },
        { { 0.430349f, -0.125575f, 0.221429f }, { 0.865000f, -0.243100f, 0.439000f }, { 0.295455f , 0.196826f } },
        { { -0.138194f, -0.223610f, 0.425325f }, { -0.276400f, -0.447200f, 0.850600f }, { 0.090910f , 0.157461f } },
        { { -0.014820f, -0.251151f, 0.432092f }, { -0.019800f, -0.503800f, 0.863600f }, { 0.136364f , 0.157461f } },
        { { -0.077608f, -0.125576f, 0.477711f }, { -0.150200f, -0.243100f, 0.958300f }, { 0.113637f , 0.196826f } },
        { { -0.447213f, -0.223608f, 0.000000f }, { -0.894400f, -0.447200f, -0.000000f }, { 0.818182f , 0.157461f } },
        { { -0.415525f, -0.251149f, 0.119427f }, { -0.827400f, -0.503800f, 0.248000f }, { 0.863636f , 0.157461f } },
        { { -0.478313f, -0.125575f, 0.073809f }, { -0.957800f, -0.243100f, 0.153300f }, { 0.840909f , 0.196826f } },
        { { -0.138194f, -0.223610f, -0.425325f }, { -0.276400f, -0.447200f, -0.850600f }, { 0.636364f , 0.157461f } },
        { { -0.241986f, -0.251151f, -0.358282f }, { -0.491500f, -0.503800f, -0.710300f }, { 0.681818f , 0.157461f } },
        { { -0.218003f, -0.125576f, -0.432094f }, { -0.441700f, -0.243100f, -0.863600f }, { 0.659091f , 0.196826f } },
        { { 0.361804f, -0.223610f, -0.262863f }, { 0.723600f, -0.447200f, -0.525700f }, { 0.454546f , 0.157461f } },
        { { 0.265970f, -0.251151f, -0.340856f }, { 0.523700f, -0.503800f, -0.687000f }, { 0.500000f , 0.157461f } },
        { { 0.343579f, -0.125576f, -0.340858f }, { 0.684800f, -0.243100f, -0.687000f }, { 0.477273f , 0.196826f } },
        { { 0.343579f, -0.125576f, 0.340858f }, { 0.684800f, -0.243100f, 0.687000f }, { 0.250001f , 0.196826f } },
        { { -0.218003f, -0.125576f, 0.432094f }, { -0.441700f, -0.243100f, 0.863600f }, { 0.068182f , 0.196826f } },
        { { -0.478313f, -0.125575f, -0.073809f }, { -0.957800f, -0.243100f, -0.153300f }, { 0.795455f , 0.196826f } },
        { { -0.077608f, -0.125576f, -0.477711f }, { -0.150200f, -0.243100f, -0.958300f }, { 0.613637f , 0.196826f } },
        { { 0.430349f, -0.125575f, -0.221429f }, { 0.865000f, -0.243100f, -0.439000f }, { 0.431819f , 0.196826f } },
        { { 0.138194f, 0.223610f, 0.425325f }, { 0.276400f, 0.447200f, 0.850600f }, { 0.181819f , 0.314921f } },
        { { 0.241986f, 0.251151f, 0.358282f }, { 0.491500f, 0.503800f, 0.710300f }, { 0.227273f , 0.314921f } },
        { { 0.116411f, 0.328760f, 0.358282f }, { 0.230800f, 0.665000f, 0.710300f }, { 0.204546f , 0.354286f } },
        { { -0.361804f, 0.223610f, 0.262863f }, { -0.723600f, 0.447200f, 0.525700f }, { 0.000000f , 0.314921f } },
        { { -0.265970f, 0.251151f, 0.340856f }, { -0.523700f, 0.503800f, 0.687000f }, { 0.045455f , 0.314921f } },
        { { -0.304773f, 0.328759f, 0.221428f }, { -0.604200f, 0.665000f, 0.439000f }, { 0.022727f , 0.354286f } },
        { { -0.361804f, 0.223610f, -0.262863f }, { -0.723600f, 0.447200f, -0.525700f }, { 0.727273f , 0.314921f } },
        { { -0.406365f, 0.251150f, -0.147619f }, { -0.815200f, 0.503800f, -0.285700f }, { 0.772727f , 0.314921f } },
        { { -0.304773f, 0.328759f, -0.221428f }, { -0.604200f, 0.665000f, -0.439000f }, { 0.750000f , 0.354286f } },
        { { 0.138194f, 0.223610f, -0.425325f }, { 0.276400f, 0.447200f, -0.850600f }, { 0.545455f , 0.314921f } },
        { { 0.014820f, 0.251151f, -0.432092f }, { 0.019800f, 0.503800f, -0.863600f }, { 0.590909f , 0.314921f } },
        { { 0.116411f, 0.328760f, -0.358282f }, { 0.230800f, 0.665000f, -0.710300f }, { 0.568182f , 0.354286f } },
        { { 0.447213f, 0.223608f, 0.000000f }, { 0.894400f, 0.447200f, -0.000000f }, { 0.363637f , 0.314921f } },
        { { 0.415525f, 0.251149f, -0.119427f }, { 0.827400f, 0.503800f, -0.248000f }, { 0.409091f , 0.314921f } },
        { { 0.376721f, 0.328757f, 0.000000f }, { 0.746900f, 0.665000f, -0.000000f }, { 0.386364f , 0.354286f } },
        { { 0.125573f, 0.483974f, 0.000000f }, { 0.260700f, 0.965400f, -0.000000f }, { 0.431819f , 0.433017f } },
        { { 0.038803f, 0.483975f, -0.119426f }, { 0.080600f, 0.965400f, -0.248000f }, { 0.477273f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.454546f , 0.472382f } },
        { { 0.262865f, 0.425326f, 0.000000f }, { 0.525700f, 0.850700f, -0.000000f }, { 0.409091f , 0.393651f } },
        { { 0.180900f, 0.447215f, -0.131431f }, { 0.368200f, 0.890400f, -0.267500f }, { 0.454546f , 0.393651f } },
        { { 0.319097f, 0.361805f, -0.131432f }, { 0.631700f, 0.727500f, -0.267500f }, { 0.431819f , 0.354286f } },
        { { 0.081228f, 0.425327f, -0.249998f }, { 0.162500f, 0.850700f, -0.500000f }, { 0.500000f , 0.393651f } },
        { { 0.223605f, 0.361806f, -0.262864f }, { 0.449600f, 0.727600f, -0.518200f }, { 0.477273f , 0.354286f } },
        { { 0.116411f, 0.328760f, -0.358282f }, { 0.230800f, 0.665000f, -0.710300f }, { 0.522728f , 0.354286f } },
        { { 0.344095f, 0.262868f, -0.249998f }, { 0.688200f, 0.525700f, -0.500000f }, { 0.454546f , 0.314921f } },
        { { 0.241986f, 0.251151f, -0.358282f }, { 0.491500f, 0.503800f, -0.710300f }, { 0.500000f , 0.314921f } },
        { { 0.038803f, 0.483975f, -0.119426f }, { 0.080600f, 0.965400f, -0.248000f }, { 0.613637f , 0.433017f } },
        { { -0.101590f, 0.483975f, -0.073809f }, { -0.211000f, 0.965400f, -0.153300f }, { 0.659091f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.636364f , 0.472382f } },
        { { 0.081228f, 0.425327f, -0.249998f }, { 0.162500f, 0.850700f, -0.500000f }, { 0.590909f , 0.393651f } },
        { { -0.069099f, 0.447215f, -0.212660f }, { -0.140600f, 0.890400f, -0.432900f }, { 0.636364f , 0.393651f } },
        { { -0.026395f, 0.361806f, -0.344092f }, { -0.059200f, 0.727600f, -0.683500f }, { 0.613637f , 0.354286f } },
        { { -0.212661f, 0.425327f, -0.154506f }, { -0.425300f, 0.850700f, -0.309000f }, { 0.681818f , 0.393651f } },
        { { -0.180902f, 0.361806f, -0.293889f }, { -0.353900f, 0.727600f, -0.587800f }, { 0.659091f , 0.354286f } },
        { { -0.304773f, 0.328759f, -0.221428f }, { -0.604200f, 0.665000f, -0.439000f }, { 0.704546f , 0.354286f } },
        { { -0.131434f, 0.262869f, -0.404506f }, { -0.262900f, 0.525700f, -0.809000f }, { 0.636364f , 0.314921f } },
        { { -0.265970f, 0.251151f, -0.340856f }, { -0.523700f, 0.503800f, -0.687000f }, { 0.681818f , 0.314921f } },
        { { -0.101590f, 0.483975f, -0.073809f }, { -0.211000f, 0.965400f, -0.153300f }, { 0.795455f , 0.433017f } },
        { { -0.101590f, 0.483975f, 0.073809f }, { -0.211000f, 0.965400f, 0.153300f }, { 0.840909f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.818182f , 0.472382f } },
        { { -0.212661f, 0.425327f, -0.154506f }, { -0.425300f, 0.850700f, -0.309000f }, { 0.772727f , 0.393651f } },
        { { -0.223605f, 0.447215f, 0.000000f }, { -0.455100f, 0.890400f, -0.000000f }, { 0.818182f , 0.393651f } },
        { { -0.335408f, 0.361805f, -0.081229f }, { -0.668300f, 0.727600f, -0.154900f }, { 0.795455f , 0.354286f } },
        { { -0.212661f, 0.425327f, 0.154506f }, { -0.425300f, 0.850700f, 0.309000f }, { 0.863636f , 0.393651f } },
        { { -0.335408f, 0.361805f, 0.081229f }, { -0.668300f, 0.727600f, 0.154900f }, { 0.840909f , 0.354286f } },
        { { -0.304773f, 0.328759f, 0.221428f }, { -0.604200f, 0.665000f, 0.439000f }, { 0.886364f , 0.354286f } },
        { { -0.425324f, 0.262868f, 0.000000f }, { -0.850600f, 0.525700f, -0.000000f }, { 0.818182f , 0.314921f } },
        { { -0.406365f, 0.251150f, 0.147619f }, { -0.815200f, 0.503800f, 0.285700f }, { 0.863636f , 0.314921f } },
        { { -0.361804f, 0.223610f, 0.262863f }, { -0.723600f, 0.447200f, 0.525700f }, { 0.909091f , 0.314921f } },
        { { -0.101590f, 0.483975f, 0.073809f }, { -0.211000f, 0.965400f, 0.153300f }, { 0.068182f , 0.433017f } },
        { { 0.038803f, 0.483975f, 0.119426f }, { 0.080600f, 0.965400f, 0.248000f }, { 0.113637f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.090910f , 0.472382f } },
        { { -0.212661f, 0.425327f, 0.154506f }, { -0.425300f, 0.850700f, 0.309000f }, { 0.045455f , 0.393651f } },
        { { -0.069099f, 0.447215f, 0.212660f }, { -0.140600f, 0.890400f, 0.432900f }, { 0.090910f , 0.393651f } },
        { { -0.180902f, 0.361806f, 0.293889f }, { -0.353900f, 0.727600f, 0.587800f }, { 0.068182f , 0.354286f } },
        { { 0.081228f, 0.425327f, 0.249998f }, { 0.162500f, 0.850700f, 0.500000f }, { 0.136365f , 0.393651f } },
        { { -0.026395f, 0.361806f, 0.344092f }, { -0.059200f, 0.727600f, 0.683500f }, { 0.113637f , 0.354286f } },
        { { 0.116411f, 0.328760f, 0.358282f }, { 0.230800f, 0.665000f, 0.710300f }, { 0.159092f , 0.354286f } },
        { { -0.131434f, 0.262869f, 0.404506f }, { -0.262900f, 0.525700f, 0.809000f }, { 0.090909f , 0.314921f } },
        { { 0.014820f, 0.251151f, 0.432092f }, { 0.019800f, 0.503800f, 0.863600f }, { 0.136364f , 0.314921f } },
        { { 0.038803f, 0.483975f, 0.119426f }, { 0.080600f, 0.965400f, 0.248000f }, { 0.250001f , 0.433017f } },
        { { 0.125573f, 0.483974f, 0.000000f }, { 0.260700f, 0.965400f, -0.000000f }, { 0.295455f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.272728f , 0.472382f } },
        { { 0.081228f, 0.425327f, 0.249998f }, { 0.162500f, 0.850700f, 0.500000f }, { 0.227273f , 0.393651f } },
        { { 0.180900f, 0.447215f, 0.131431f }, { 0.368200f, 0.890400f, 0.267500f }, { 0.272728f , 0.393651f } },
        { { 0.223605f, 0.361806f, 0.262864f }, { 0.449600f, 0.727600f, 0.518200f }, { 0.250001f , 0.354286f } },
        { { 0.262865f, 0.425326f, 0.000000f }, { 0.525700f, 0.850700f, -0.000000f }, { 0.318182f , 0.393651f } },
        { { 0.319097f, 0.361805f, 0.131432f }, { 0.631700f, 0.727500f, 0.267500f }, { 0.295455f , 0.354286f } },
        { { 0.376721f, 0.328757f, 0.000000f }, { 0.746900f, 0.665000f, -0.000000f }, { 0.340910f , 0.354286f } },
        { { 0.344095f, 0.262868f, 0.249998f }, { 0.688200f, 0.525700f, 0.500000f }, { 0.272728f , 0.314921f } },
        { { 0.415525f, 0.251149f, 0.119427f }, { 0.827400f, 0.503800f, 0.248000f }, { 0.318182f , 0.314921f } },
        { { 0.478313f, 0.125575f, -0.073809f }, { 0.957800f, 0.243100f, -0.153300f }, { 0.386364f , 0.275556f } },
        { { 0.475529f, 0.000000f, -0.154506f }, { 0.951100f, -0.000000f, -0.309000f }, { 0.409091f , 0.236191f } },
        { { 0.430902f, 0.138198f, -0.212661f }, { 0.859300f, 0.272400f, -0.432900f }, { 0.431819f , 0.275556f } },
        { { 0.404510f, 0.000000f, -0.293891f }, { 0.809000f, 0.008900f, -0.587800f }, { 0.454546f , 0.236191f } },
        { { 0.335410f, 0.138199f, -0.344095f }, { 0.677200f, 0.272400f, -0.683500f }, { 0.477273f , 0.275556f } },
        { { 0.293893f, -0.000000f, -0.404508f }, { 0.587800f, -0.000000f, -0.809000f }, { 0.500000f , 0.236191f } },
        { { 0.218003f, 0.125576f, -0.432094f }, { 0.441700f, 0.243100f, -0.863600f }, { 0.522728f , 0.275556f } },
        { { 0.077608f, 0.125576f, -0.477711f }, { 0.150200f, 0.243100f, -0.958300f }, { 0.568182f , 0.275556f } },
        { { 0.000000f, 0.000000f, -0.500000f }, { -0.000000f, -0.000000f, -1.000000f }, { 0.590909f , 0.236191f } },
        { { -0.069099f, 0.138199f, -0.475528f }, { -0.146100f, 0.272400f, -0.951000f }, { 0.613637f , 0.275556f } },
        { { -0.154508f, -0.000000f, -0.475528f }, { -0.309000f, 0.008900f, -0.951000f }, { 0.636364f , 0.236191f } },
        { { -0.223608f, 0.138199f, -0.425324f }, { -0.440800f, 0.272400f, -0.855300f }, { 0.659091f , 0.275556f } },
        { { -0.293893f, -0.000000f, -0.404508f }, { -0.587800f, -0.000000f, -0.809000f }, { 0.681818f , 0.236191f } },
        { { -0.343579f, 0.125576f, -0.340858f }, { -0.684800f, 0.243100f, -0.687000f }, { 0.704546f , 0.275556f } },
        { { -0.430349f, 0.125575f, -0.221429f }, { -0.865000f, 0.243100f, -0.439000f }, { 0.750000f , 0.275556f } },
        { { -0.475529f, 0.000000f, -0.154506f }, { -0.951100f, -0.000000f, -0.309000f }, { 0.772727f , 0.236191f } },
        { { -0.473607f, 0.138198f, -0.081229f }, { -0.949600f, 0.272400f, -0.154900f }, { 0.795455f , 0.275556f } },
        { { -0.500000f, 0.000000f, 0.000000f }, { -1.000000f, 0.008900f, -0.000000f }, { 0.818182f , 0.236191f } },
        { { -0.473606f, 0.138198f, 0.081229f }, { -0.949600f, 0.272400f, 0.154900f }, { 0.840909f , 0.275556f } },
        { { -0.475529f, -0.000000f, 0.154506f }, { -0.951100f, -0.000000f, 0.309000f }, { 0.863636f , 0.236191f } },
        { { -0.430349f, 0.125575f, 0.221429f }, { -0.865000f, 0.243100f, 0.439000f }, { 0.886364f , 0.275556f } },
        { { -0.343579f, 0.125576f, 0.340858f }, { -0.684800f, 0.243100f, 0.687000f }, { 0.022727f , 0.275556f } },
        { { -0.293893f, 0.000000f, 0.404508f }, { -0.587800f, -0.000000f, 0.809000f }, { 0.045455f , 0.236191f } },
        { { -0.223608f, 0.138198f, 0.425324f }, { -0.440800f, 0.272400f, 0.855300f }, { 0.068182f , 0.275556f } },
        { { -0.154509f, -0.000000f, 0.475528f }, { -0.309000f, 0.008900f, 0.951000f }, { 0.090910f , 0.236191f } },
        { { -0.069100f, 0.138198f, 0.475528f }, { -0.146100f, 0.272400f, 0.951000f }, { 0.113637f , 0.275556f } },
        { { 0.000000f, -0.000000f, 0.500000f }, { -0.000000f, -0.000000f, 1.000000f }, { 0.136364f , 0.236191f } },
        { { 0.077608f, 0.125576f, 0.477711f }, { 0.150200f, 0.243100f, 0.958300f }, { 0.159092f , 0.275556f } },
        { { 0.218003f, 0.125576f, 0.432094f }, { 0.441700f, 0.243100f, 0.863600f }, { 0.204546f , 0.275556f } },
        { { 0.293893f, 0.000000f, 0.404508f }, { 0.587800f, -0.000000f, 0.809000f }, { 0.227273f , 0.236191f } },
        { { 0.335410f, 0.138198f, 0.344095f }, { 0.677200f, 0.272400f, 0.683500f }, { 0.250001f , 0.275556f } },
        { { 0.404509f, -0.000001f, 0.293891f }, { 0.809000f, 0.008900f, 0.587800f }, { 0.272728f , 0.236191f } },
        { { 0.430902f, 0.138197f, 0.212662f }, { 0.859300f, 0.272400f, 0.432900f }, { 0.295455f , 0.275556f } },
        { { 0.475529f, -0.000000f, 0.154506f }, { 0.951100f, -0.000000f, 0.309000f }, { 0.318182f , 0.236191f } },
        { { 0.478313f, 0.125575f, 0.073809f }, { 0.957800f, 0.243100f, 0.153300f }, { 0.340910f , 0.275556f } },
        { { 0.154509f, -0.000000f, -0.475528f }, { 0.309000f, -0.008900f, -0.951000f }, { 0.545455f , 0.236191f } },
        { { 0.223608f, -0.138199f, -0.425324f }, { 0.440800f, -0.272400f, -0.855300f }, { 0.522728f , 0.196826f } },
        { { 0.069100f, -0.138199f, -0.475527f }, { 0.146100f, -0.272400f, -0.951000f }, { 0.568182f , 0.196826f } },
        { { 0.131434f, -0.262869f, -0.404506f }, { 0.262900f, -0.525700f, -0.809000f }, { 0.545455f , 0.157461f } },
        { { -0.014820f, -0.251151f, -0.432092f }, { -0.019800f, -0.503800f, -0.863600f }, { 0.590909f , 0.157461f } },
        { { -0.404509f, -0.000000f, -0.293892f }, { -0.809000f, -0.008900f, -0.587800f }, { 0.727273f , 0.236191f } },
        { { -0.335409f, -0.138199f, -0.344095f }, { -0.677200f, -0.272400f, -0.683500f }, { 0.704546f , 0.196826f } },
        { { -0.430902f, -0.138198f, -0.212662f }, { -0.859300f, -0.272400f, -0.432900f }, { 0.750000f , 0.196826f } },
        { { -0.344095f, -0.262868f, -0.249998f }, { -0.688200f, -0.525700f, -0.500000f }, { 0.727273f , 0.157461f } },
        { { -0.415525f, -0.251149f, -0.119427f }, { -0.827400f, -0.503800f, -0.248000f }, { 0.772727f , 0.157461f } },
        { { -0.343579f, 0.125576f, 0.340858f }, { -0.684800f, 0.243100f, 0.687000f }, { 0.931818f , 0.275556f } },
        { { -0.404509f, 0.000000f, 0.293892f }, { -0.809000f, -0.008900f, 0.587800f }, { 0.909091f , 0.236191f } },
        { { -0.430902f, -0.138198f, 0.212662f }, { -0.859300f, -0.272400f, 0.432900f }, { 0.886364f , 0.196826f } },
        { { -0.293893f, 0.000000f, 0.404508f }, { -0.587800f, -0.000000f, 0.809000f }, { 0.954545f , 0.236191f } },
        { { -0.335410f, -0.138199f, 0.344095f }, { -0.677200f, -0.272400f, 0.683500f }, { 0.931818f , 0.196826f } },
        { { -0.218003f, -0.125576f, 0.432094f }, { -0.441700f, -0.243100f, 0.863600f }, { 0.977273f , 0.196826f } },
        { { -0.344095f, -0.262868f, 0.249998f }, { -0.688200f, -0.525700f, 0.500000f }, { 0.909091f , 0.157461f } },
        { { -0.241986f, -0.251151f, 0.358282f }, { -0.491500f, -0.503800f, 0.710300f }, { 0.954545f , 0.157461f } },
        { { -0.138194f, -0.223610f, 0.425325f }, { -0.276400f, -0.447200f, 0.850600f }, { 1.000000f , 0.157461f } },
        { { 0.154509f, 0.000000f, 0.475528f }, { 0.309000f, -0.008900f, 0.951000f }, { 0.181819f , 0.236191f } },
        { { 0.069100f, -0.138199f, 0.475527f }, { 0.146100f, -0.272400f, 0.951000f }, { 0.159092f , 0.196826f } },
        { { 0.223608f, -0.138199f, 0.425324f }, { 0.440800f, -0.272400f, 0.855300f }, { 0.204546f , 0.196826f } },
        { { 0.131434f, -0.262869f, 0.404506f }, { 0.262900f, -0.525700f, 0.809000f }, { 0.181819f , 0.157461f } },
        { { 0.265970f, -0.251151f, 0.340856f }, { 0.523700f, -0.503800f, 0.687000f }, { 0.227274f , 0.157461f } },
        { { 0.500000f, 0.000000f, 0.000000f }, { 1.000000f, -0.008900f, -0.000000f }, { 0.363637f , 0.236191f } },
        { { 0.473607f, -0.138198f, 0.081229f }, { 0.949600f, -0.272400f, 0.154900f }, { 0.340910f , 0.196826f } },
        { { 0.473607f, -0.138198f, -0.081229f }, { 0.949600f, -0.272400f, -0.154900f }, { 0.386364f , 0.196826f } },
        { { 0.425324f, -0.262868f, 0.000000f }, { 0.850600f, -0.525700f, -0.000000f }, { 0.363637f , 0.157461f } },
        { { 0.406365f, -0.251150f, -0.147619f }, { 0.815200f, -0.503800f, -0.285700f }, { 0.409092f , 0.157461f } },
        { { 0.304773f, -0.328759f, -0.221428f }, { 0.604200f, -0.665000f, -0.439000f }, { 0.477273f , 0.118096f } },
        { { 0.212661f, -0.425327f, -0.154506f }, { 0.425300f, -0.850700f, -0.309000f }, { 0.500000f , 0.078731f } },
        { { 0.180902f, -0.361806f, -0.293890f }, { 0.353900f, -0.727600f, -0.587800f }, { 0.522728f , 0.118096f } },
        { { 0.069098f, -0.447215f, -0.212661f }, { 0.140600f, -0.890400f, -0.432900f }, { 0.545455f , 0.078731f } },
        { { 0.026395f, -0.361805f, -0.344093f }, { 0.059200f, -0.727600f, -0.683500f }, { 0.568182f , 0.118096f } },
        { { -0.081228f, -0.425327f, -0.249998f }, { -0.162500f, -0.850700f, -0.500000f }, { 0.590909f , 0.078731f } },
        { { -0.116411f, -0.328760f, -0.358282f }, { -0.230800f, -0.665000f, -0.710300f }, { 0.613637f , 0.118096f } },
        { { -0.116411f, -0.328760f, -0.358282f }, { -0.230800f, -0.665000f, -0.710300f }, { 0.659091f , 0.118096f } },
        { { -0.081228f, -0.425327f, -0.249998f }, { -0.162500f, -0.850700f, -0.500000f }, { 0.681818f , 0.078731f } },
        { { -0.223605f, -0.361806f, -0.262864f }, { -0.449600f, -0.727600f, -0.518200f }, { 0.704546f , 0.118096f } },
        { { -0.180901f, -0.447214f, -0.131431f }, { -0.368200f, -0.890400f, -0.267500f }, { 0.727273f , 0.078731f } },
        { { -0.319097f, -0.361805f, -0.131431f }, { -0.631700f, -0.727500f, -0.267500f }, { 0.750000f , 0.118096f } },
        { { -0.262865f, -0.425326f, 0.000000f }, { -0.525700f, -0.850700f, -0.000000f }, { 0.772727f , 0.078731f } },
        { { -0.376721f, -0.328757f, 0.000000f }, { -0.746900f, -0.665000f, -0.000000f }, { 0.795455f , 0.118096f } },
        { { -0.376721f, -0.328757f, 0.000000f }, { -0.746900f, -0.665000f, -0.000000f }, { 0.840909f , 0.118096f } },
        { { -0.262865f, -0.425326f, 0.000000f }, { -0.525700f, -0.850700f, -0.000000f }, { 0.863636f , 0.078731f } },
        { { -0.319097f, -0.361805f, 0.131432f }, { -0.631700f, -0.727500f, 0.267500f }, { 0.886364f , 0.118096f } },
        { { -0.180901f, -0.447214f, 0.131432f }, { -0.368200f, -0.890400f, 0.267500f }, { 0.909091f , 0.078731f } },
        { { -0.223605f, -0.361805f, 0.262864f }, { -0.449600f, -0.727500f, 0.518200f }, { 0.931818f , 0.118096f } },
        { { -0.081228f, -0.425327f, 0.249998f }, { -0.162500f, -0.850700f, 0.500000f }, { 0.954545f , 0.078731f } },
        { { -0.116411f, -0.328760f, 0.358282f }, { -0.230800f, -0.665000f, 0.710300f }, { 0.977273f , 0.118096f } },
        { { 0.304773f, -0.328759f, -0.221428f }, { 0.604200f, -0.665000f, -0.439000f }, { 0.431819f , 0.118096f } },
        { { 0.335409f, -0.361805f, -0.081228f }, { 0.668300f, -0.727500f, -0.154900f }, { 0.386364f , 0.118096f } },
        { { 0.335409f, -0.361805f, 0.081229f }, { 0.668300f, -0.727500f, 0.154900f }, { 0.340910f , 0.118096f } },
        { { 0.212661f, -0.425327f, -0.154506f }, { 0.425300f, -0.850700f, -0.309000f }, { 0.409091f , 0.078731f } },
        { { 0.223605f, -0.447214f, 0.000000f }, { 0.455100f, -0.890400f, -0.000000f }, { 0.363637f , 0.078730f } },
        { { 0.101590f, -0.483975f, -0.073809f }, { 0.211000f, -0.965400f, -0.153300f }, { 0.386364f , 0.039365f } },
        { { 0.212661f, -0.425327f, 0.154506f }, { 0.425300f, -0.850700f, 0.309000f }, { 0.318182f , 0.078731f } },
        { { 0.101590f, -0.483975f, 0.073809f }, { 0.211000f, -0.965400f, 0.153300f }, { 0.340910f , 0.039365f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.363637f , 0.000000f } },
        { { -0.116411f, -0.328760f, 0.358282f }, { -0.230800f, -0.665000f, 0.710300f }, { 0.113637f , 0.118096f } },
        { { -0.081228f, -0.425327f, 0.249998f }, { -0.162500f, -0.850700f, 0.500000f }, { 0.136365f , 0.078731f } },
        { { 0.026395f, -0.361806f, 0.344093f }, { 0.059200f, -0.727600f, 0.683500f }, { 0.159092f , 0.118096f } },
        { { 0.069099f, -0.447215f, 0.212660f }, { 0.140600f, -0.890400f, 0.432900f }, { 0.181819f , 0.078731f } },
        { { 0.180902f, -0.361805f, 0.293890f }, { 0.353900f, -0.727600f, 0.587800f }, { 0.204546f , 0.118096f } },
        { { 0.212661f, -0.425327f, 0.154506f }, { 0.425300f, -0.850700f, 0.309000f }, { 0.227273f , 0.078731f } },
        { { 0.304773f, -0.328759f, 0.221428f }, { 0.604200f, -0.665000f, 0.439000f }, { 0.250001f , 0.118096f } },
        };
        MeshIndex indices[]
        {
        0, 1, 2,
        3, 4, 5,
        6, 7, 8,
        9, 10, 11,
        12, 13, 14,
        3, 5, 15,
        16, 17, 18,
        19, 20, 21,
        22, 23, 24,
        25, 26, 27,
        3, 15, 28,
        16, 18, 29,
        19, 21, 30,
        22, 24, 31,
        25, 27, 32,
        33, 34, 35,
        36, 37, 38,
        39, 40, 41,
        42, 43, 44,
        45, 46, 47,
        48, 49, 50,
        51, 52, 48,
        47, 53, 51,
        48, 52, 49,
        52, 54, 49,
        51, 53, 52,
        53, 55, 52,
        52, 55, 54,
        55, 56, 54,
        47, 46, 53,
        46, 57, 53,
        53, 57, 55,
        57, 58, 55,
        55, 58, 56,
        58, 42, 56,
        59, 60, 61,
        62, 63, 59,
        44, 64, 62,
        59, 63, 60,
        63, 65, 60,
        62, 64, 63,
        64, 66, 63,
        63, 66, 65,
        66, 67, 65,
        44, 43, 64,
        43, 68, 64,
        64, 68, 66,
        68, 69, 66,
        66, 69, 67,
        69, 39, 67,
        70, 71, 72,
        73, 74, 70,
        41, 75, 73,
        70, 74, 71,
        74, 76, 71,
        73, 75, 74,
        75, 77, 74,
        74, 77, 76,
        77, 78, 76,
        41, 40, 75,
        40, 79, 75,
        75, 79, 77,
        79, 80, 77,
        77, 80, 78,
        80, 81, 78,
        82, 83, 84,
        85, 86, 82,
        38, 87, 85,
        82, 86, 83,
        86, 88, 83,
        85, 87, 86,
        87, 89, 86,
        86, 89, 88,
        89, 90, 88,
        38, 37, 87,
        37, 91, 87,
        87, 91, 89,
        91, 92, 89,
        89, 92, 90,
        92, 33, 90,
        93, 94, 95,
        96, 97, 93,
        35, 98, 96,
        93, 97, 94,
        97, 99, 94,
        96, 98, 97,
        98, 100, 97,
        97, 100, 99,
        100, 101, 99,
        35, 34, 98,
        34, 102, 98,
        98, 102, 100,
        102, 103, 100,
        100, 103, 101,
        103, 45, 101,
        104, 46, 45,
        105, 106, 104,
        32, 107, 105,
        104, 106, 46,
        106, 57, 46,
        105, 107, 106,
        107, 108, 106,
        106, 108, 57,
        108, 58, 57,
        32, 27, 107,
        27, 109, 107,
        107, 109, 108,
        109, 110, 108,
        108, 110, 58,
        110, 42, 58,
        111, 43, 42,
        112, 113, 111,
        31, 114, 112,
        111, 113, 43,
        113, 68, 43,
        112, 114, 113,
        114, 115, 113,
        113, 115, 68,
        115, 69, 68,
        31, 24, 114,
        24, 116, 114,
        114, 116, 115,
        116, 117, 115,
        115, 117, 69,
        117, 39, 69,
        118, 40, 39,
        119, 120, 118,
        30, 121, 119,
        118, 120, 40,
        120, 79, 40,
        119, 121, 120,
        121, 122, 120,
        120, 122, 79,
        122, 80, 79,
        30, 21, 121,
        21, 123, 121,
        121, 123, 122,
        123, 124, 122,
        122, 124, 80,
        124, 81, 80,
        125, 37, 36,
        126, 127, 125,
        29, 128, 126,
        125, 127, 37,
        127, 91, 37,
        126, 128, 127,
        128, 129, 127,
        127, 129, 91,
        129, 92, 91,
        29, 18, 128,
        18, 130, 128,
        128, 130, 129,
        130, 131, 129,
        129, 131, 92,
        131, 33, 92,
        132, 34, 33,
        133, 134, 132,
        28, 135, 133,
        132, 134, 34,
        134, 102, 34,
        133, 135, 134,
        135, 136, 134,
        134, 136, 102,
        136, 103, 102,
        28, 15, 135,
        15, 137, 135,
        135, 137, 136,
        137, 138, 136,
        136, 138, 103,
        138, 45, 103,
        110, 111, 42,
        109, 139, 110,
        27, 140, 109,
        110, 139, 111,
        139, 112, 111,
        109, 140, 139,
        140, 141, 139,
        139, 141, 112,
        141, 31, 112,
        27, 26, 140,
        26, 142, 140,
        140, 142, 141,
        142, 143, 141,
        141, 143, 31,
        143, 22, 31,
        117, 118, 39,
        116, 144, 117,
        24, 145, 116,
        117, 144, 118,
        144, 119, 118,
        116, 145, 144,
        145, 146, 144,
        144, 146, 119,
        146, 30, 119,
        24, 23, 145,
        23, 147, 145,
        145, 147, 146,
        147, 148, 146,
        146, 148, 30,
        148, 19, 30,
        124, 149, 81,
        123, 150, 124,
        21, 151, 123,
        124, 150, 149,
        150, 152, 149,
        123, 151, 150,
        151, 153, 150,
        150, 153, 152,
        153, 154, 152,
        21, 20, 151,
        20, 155, 151,
        151, 155, 153,
        155, 156, 153,
        153, 156, 154,
        156, 157, 154,
        131, 132, 33,
        130, 158, 131,
        18, 159, 130,
        131, 158, 132,
        158, 133, 132,
        130, 159, 158,
        159, 160, 158,
        158, 160, 133,
        160, 28, 133,
        18, 17, 159,
        17, 161, 159,
        159, 161, 160,
        161, 162, 160,
        160, 162, 28,
        162, 3, 28,
        138, 104, 45,
        137, 163, 138,
        15, 164, 137,
        138, 163, 104,
        163, 105, 104,
        137, 164, 163,
        164, 165, 163,
        163, 165, 105,
        165, 32, 105,
        15, 5, 164,
        5, 166, 164,
        164, 166, 165,
        166, 167, 165,
        165, 167, 32,
        167, 25, 32,
        168, 26, 25,
        169, 170, 168,
        14, 171, 169,
        168, 170, 26,
        170, 142, 26,
        169, 171, 170,
        171, 172, 170,
        170, 172, 142,
        172, 143, 142,
        14, 13, 171,
        13, 173, 171,
        171, 173, 172,
        173, 174, 172,
        172, 174, 143,
        174, 22, 143,
        175, 23, 22,
        176, 177, 175,
        11, 178, 176,
        175, 177, 23,
        177, 147, 23,
        176, 178, 177,
        178, 179, 177,
        177, 179, 147,
        179, 148, 147,
        11, 10, 178,
        10, 180, 178,
        178, 180, 179,
        180, 181, 179,
        179, 181, 148,
        181, 19, 148,
        182, 20, 19,
        183, 184, 182,
        8, 185, 183,
        182, 184, 20,
        184, 155, 20,
        183, 185, 184,
        185, 186, 184,
        184, 186, 155,
        186, 156, 155,
        8, 7, 185,
        7, 187, 185,
        185, 187, 186,
        187, 188, 186,
        186, 188, 156,
        188, 157, 156,
        167, 189, 25,
        166, 190, 167,
        5, 191, 166,
        167, 190, 189,
        190, 192, 189,
        166, 191, 190,
        191, 193, 190,
        190, 193, 192,
        193, 194, 192,
        5, 4, 191,
        4, 195, 191,
        191, 195, 193,
        195, 196, 193,
        193, 196, 194,
        196, 197, 194,
        198, 17, 16,
        199, 200, 198,
        2, 201, 199,
        198, 200, 17,
        200, 161, 17,
        199, 201, 200,
        201, 202, 200,
        200, 202, 161,
        202, 162, 161,
        2, 1, 201,
        1, 203, 201,
        201, 203, 202,
        203, 204, 202,
        202, 204, 162,
        204, 3, 162,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::Cone(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
        { { 0.000000f, -0.500000f, -0.500000f }, { -0.000000f, -0.514200f, -0.857700f }, { 0.250000f , 0.490000f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.250000f , 0.250000f } },
        { { 0.049009f, -0.500000f, -0.497592f }, { 0.084100f, -0.514200f, -0.853600f }, { 0.273524f , 0.488844f } },
        { { 0.097545f, -0.500000f, -0.490393f }, { 0.167300f, -0.514200f, -0.841200f }, { 0.296822f , 0.485388f } },
        { { 0.145142f, -0.500000f, -0.478470f }, { 0.249000f, -0.514200f, -0.820800f }, { 0.319668f , 0.479666f } },
        { { 0.191342f, -0.500000f, -0.461940f }, { 0.328200f, -0.514200f, -0.792400f }, { 0.341844f , 0.471731f } },
        { { 0.235698f, -0.500000f, -0.440961f }, { 0.404300f, -0.514200f, -0.756400f }, { 0.363135f , 0.461661f } },
        { { 0.277785f, -0.500000f, -0.415735f }, { 0.476500f, -0.514200f, -0.713100f }, { 0.383337f , 0.449553f } },
        { { 0.317197f, -0.500000f, -0.386505f }, { 0.544100f, -0.514100f, -0.663000f }, { 0.402254f , 0.435522f } },
        { { 0.353553f, -0.500000f, -0.353553f }, { 0.606500f, -0.514200f, -0.606500f }, { 0.419706f , 0.419706f } },
        { { 0.386505f, -0.500000f, -0.317197f }, { 0.663000f, -0.514200f, -0.544100f }, { 0.435522f , 0.402254f } },
        { { 0.415735f, -0.500000f, -0.277785f }, { 0.713100f, -0.514200f, -0.476500f }, { 0.449553f , 0.383337f } },
        { { 0.440961f, -0.500000f, -0.235698f }, { 0.756400f, -0.514200f, -0.404300f }, { 0.461661f , 0.363135f } },
        { { 0.461940f, -0.500000f, -0.191342f }, { 0.792400f, -0.514200f, -0.328200f }, { 0.471731f , 0.341844f } },
        { { 0.478470f, -0.500000f, -0.145142f }, { 0.820800f, -0.514200f, -0.249000f }, { 0.479666f , 0.319668f } },
        { { 0.490393f, -0.500000f, -0.097545f }, { 0.841200f, -0.514200f, -0.167300f }, { 0.485388f , 0.296822f } },
        { { 0.497592f, -0.500000f, -0.049009f }, { 0.853600f, -0.514100f, -0.084100f }, { 0.488844f , 0.273524f } },
        { { 0.500000f, -0.500000f, 0.000000f }, { 0.857700f, -0.514200f, -0.000000f }, { 0.490000f , 0.250000f } },
        { { 0.497592f, -0.500000f, 0.049009f }, { 0.853600f, -0.514200f, 0.084100f }, { 0.488844f , 0.226476f } },
        { { 0.490393f, -0.500000f, 0.097545f }, { 0.841200f, -0.514200f, 0.167300f }, { 0.485388f , 0.203178f } },
        { { 0.478470f, -0.500000f, 0.145142f }, { 0.820800f, -0.514200f, 0.249000f }, { 0.479666f , 0.180332f } },
        { { 0.461940f, -0.500000f, 0.191342f }, { 0.792400f, -0.514200f, 0.328200f }, { 0.471731f , 0.158156f } },
        { { 0.440961f, -0.500000f, 0.235698f }, { 0.756400f, -0.514200f, 0.404300f }, { 0.461661f , 0.136865f } },
        { { 0.415735f, -0.500000f, 0.277785f }, { 0.713100f, -0.514200f, 0.476500f }, { 0.449553f , 0.116663f } },
        { { 0.386505f, -0.500000f, 0.317197f }, { 0.663000f, -0.514100f, 0.544100f }, { 0.435522f , 0.097746f } },
        { { 0.353553f, -0.500000f, 0.353553f }, { 0.606500f, -0.514200f, 0.606500f }, { 0.419706f , 0.080294f } },
        { { 0.317197f, -0.500000f, 0.386505f }, { 0.544100f, -0.514200f, 0.663000f }, { 0.402254f , 0.064478f } },
        { { 0.277785f, -0.500000f, 0.415735f }, { 0.476500f, -0.514200f, 0.713100f }, { 0.383337f , 0.050447f } },
        { { 0.235698f, -0.500000f, 0.440961f }, { 0.404300f, -0.514200f, 0.756400f }, { 0.363135f , 0.038339f } },
        { { 0.191342f, -0.500000f, 0.461940f }, { 0.328200f, -0.514200f, 0.792400f }, { 0.341844f , 0.028269f } },
        { { 0.145142f, -0.500000f, 0.478470f }, { 0.249000f, -0.514200f, 0.820800f }, { 0.319668f , 0.020334f } },
        { { 0.097545f, -0.500000f, 0.490393f }, { 0.167300f, -0.514200f, 0.841200f }, { 0.296822f , 0.014612f } },
        { { 0.049009f, -0.500000f, 0.497592f }, { 0.084100f, -0.514100f, 0.853600f }, { 0.273524f , 0.011156f } },
        { { 0.000000f, -0.500000f, 0.500000f }, { -0.000000f, -0.514200f, 0.857700f }, { 0.250000f , 0.010000f } },
        { { -0.049009f, -0.500000f, 0.497592f }, { -0.084100f, -0.514200f, 0.853600f }, { 0.226476f , 0.011156f } },
        { { -0.097545f, -0.500000f, 0.490393f }, { -0.167300f, -0.514200f, 0.841200f }, { 0.203178f , 0.014612f } },
        { { -0.145142f, -0.500000f, 0.478470f }, { -0.249000f, -0.514200f, 0.820800f }, { 0.180332f , 0.020334f } },
        { { -0.191342f, -0.500000f, 0.461940f }, { -0.328200f, -0.514200f, 0.792400f }, { 0.158156f , 0.028269f } },
        { { -0.235698f, -0.500000f, 0.440961f }, { -0.404300f, -0.514200f, 0.756400f }, { 0.136865f , 0.038339f } },
        { { -0.277785f, -0.500000f, 0.415735f }, { -0.476500f, -0.514200f, 0.713100f }, { 0.116663f , 0.050447f } },
        { { -0.317197f, -0.500000f, 0.386505f }, { -0.544100f, -0.514100f, 0.663000f }, { 0.097746f , 0.064478f } },
        { { -0.353553f, -0.500000f, 0.353553f }, { -0.606500f, -0.514200f, 0.606500f }, { 0.080294f , 0.080294f } },
        { { -0.386505f, -0.500000f, 0.317197f }, { -0.663000f, -0.514200f, 0.544100f }, { 0.064478f , 0.097746f } },
        { { -0.415735f, -0.500000f, 0.277785f }, { -0.713100f, -0.514200f, 0.476500f }, { 0.050447f , 0.116663f } },
        { { -0.440961f, -0.500000f, 0.235698f }, { -0.756400f, -0.514200f, 0.404300f }, { 0.038339f , 0.136865f } },
        { { -0.461940f, -0.500000f, 0.191342f }, { -0.792400f, -0.514200f, 0.328200f }, { 0.028269f , 0.158156f } },
        { { -0.478470f, -0.500000f, 0.145142f }, { -0.820800f, -0.514200f, 0.249000f }, { 0.020334f , 0.180332f } },
        { { -0.490393f, -0.500000f, 0.097545f }, { -0.841200f, -0.514200f, 0.167300f }, { 0.014612f , 0.203178f } },
        { { -0.497592f, -0.500000f, 0.049009f }, { -0.853600f, -0.514100f, 0.084100f }, { 0.011156f , 0.226476f } },
        { { -0.500000f, -0.500000f, 0.000000f }, { -0.857700f, -0.514200f, -0.000000f }, { 0.010000f , 0.250000f } },
        { { -0.497592f, -0.500000f, -0.049009f }, { -0.853600f, -0.514200f, -0.084100f }, { 0.011156f , 0.273524f } },
        { { -0.490393f, -0.500000f, -0.097545f }, { -0.841200f, -0.514200f, -0.167300f }, { 0.014612f , 0.296822f } },
        { { -0.478470f, -0.500000f, -0.145142f }, { -0.820800f, -0.514200f, -0.249000f }, { 0.020334f , 0.319668f } },
        { { -0.461940f, -0.500000f, -0.191342f }, { -0.792400f, -0.514200f, -0.328200f }, { 0.028269f , 0.341844f } },
        { { -0.440961f, -0.500000f, -0.235698f }, { -0.756400f, -0.514200f, -0.404300f }, { 0.038339f , 0.363135f } },
        { { -0.415735f, -0.500000f, -0.277785f }, { -0.713100f, -0.514200f, -0.476500f }, { 0.050447f , 0.383337f } },
        { { -0.386505f, -0.500000f, -0.317197f }, { -0.663000f, -0.514100f, -0.544100f }, { 0.064478f , 0.402254f } },
        { { -0.353553f, -0.500000f, -0.353553f }, { -0.606500f, -0.514200f, -0.606500f }, { 0.080294f , 0.419706f } },
        { { -0.317197f, -0.500000f, -0.386505f }, { -0.544100f, -0.514200f, -0.663000f }, { 0.097746f , 0.435522f } },
        { { -0.277785f, -0.500000f, -0.415735f }, { -0.476500f, -0.514200f, -0.713100f }, { 0.116663f , 0.449553f } },
        { { -0.235698f, -0.500000f, -0.440961f }, { -0.404300f, -0.514200f, -0.756400f }, { 0.136865f , 0.461661f } },
        { { -0.191342f, -0.500000f, -0.461940f }, { -0.328200f, -0.514200f, -0.792400f }, { 0.158156f , 0.471731f } },
        { { -0.145142f, -0.500000f, -0.478470f }, { -0.249000f, -0.514200f, -0.820800f }, { 0.180332f , 0.479666f } },
        { { -0.097545f, -0.500000f, -0.490393f }, { -0.167300f, -0.514200f, -0.841200f }, { 0.203178f , 0.485388f } },
        { { 0.049009f, -0.500000f, 0.497592f }, { 0.084100f, -0.514100f, 0.853600f }, { 0.773524f , 0.011156f } },
        { { -0.497592f, -0.500000f, 0.049009f }, { -0.853600f, -0.514100f, 0.084100f }, { 0.511156f , 0.226476f } },
        { { -0.049009f, -0.500000f, -0.497592f }, { -0.084100f, -0.514100f, -0.853600f }, { 0.726476f , 0.488844f } },
        { { -0.049009f, -0.500000f, -0.497592f }, { -0.084100f, -0.514100f, -0.853600f }, { 0.226476f , 0.488844f } },
        { { 0.000000f, -0.500000f, -0.500000f }, { -0.000000f, -0.514200f, -0.857700f }, { 0.750000f , 0.490000f } },
        { { 0.049009f, -0.500000f, -0.497592f }, { 0.084100f, -0.514200f, -0.853600f }, { 0.773524f , 0.488844f } },
        { { 0.097545f, -0.500000f, -0.490393f }, { 0.167300f, -0.514200f, -0.841200f }, { 0.796822f , 0.485388f } },
        { { 0.145142f, -0.500000f, -0.478470f }, { 0.249000f, -0.514200f, -0.820800f }, { 0.819668f , 0.479666f } },
        { { 0.191342f, -0.500000f, -0.461940f }, { 0.328200f, -0.514200f, -0.792400f }, { 0.841844f , 0.471731f } },
        { { 0.235698f, -0.500000f, -0.440961f }, { 0.404300f, -0.514200f, -0.756400f }, { 0.863135f , 0.461661f } },
        { { 0.277785f, -0.500000f, -0.415735f }, { 0.476500f, -0.514200f, -0.713100f }, { 0.883337f , 0.449553f } },
        { { 0.317197f, -0.500000f, -0.386505f }, { 0.544100f, -0.514100f, -0.663000f }, { 0.902254f , 0.435522f } },
        { { 0.353553f, -0.500000f, -0.353553f }, { 0.606500f, -0.514200f, -0.606500f }, { 0.919706f , 0.419706f } },
        { { 0.386505f, -0.500000f, -0.317197f }, { 0.663000f, -0.514200f, -0.544100f }, { 0.935522f , 0.402254f } },
        { { 0.415735f, -0.500000f, -0.277785f }, { 0.713100f, -0.514200f, -0.476500f }, { 0.949553f , 0.383337f } },
        { { 0.440961f, -0.500000f, -0.235698f }, { 0.756400f, -0.514200f, -0.404300f }, { 0.961661f , 0.363135f } },
        { { 0.461940f, -0.500000f, -0.191342f }, { 0.792400f, -0.514200f, -0.328200f }, { 0.971731f , 0.341844f } },
        { { 0.478470f, -0.500000f, -0.145142f }, { 0.820800f, -0.514200f, -0.249000f }, { 0.979666f , 0.319668f } },
        { { 0.490393f, -0.500000f, -0.097545f }, { 0.841200f, -0.514200f, -0.167300f }, { 0.985388f , 0.296822f } },
        { { 0.497592f, -0.500000f, -0.049009f }, { 0.853600f, -0.514100f, -0.084100f }, { 0.988844f , 0.273524f } },
        { { 0.500000f, -0.500000f, 0.000000f }, { 0.857700f, -0.514200f, -0.000000f }, { 0.990000f , 0.250000f } },
        { { 0.497592f, -0.500000f, 0.049009f }, { 0.853600f, -0.514200f, 0.084100f }, { 0.988844f , 0.226476f } },
        { { 0.490393f, -0.500000f, 0.097545f }, { 0.841200f, -0.514200f, 0.167300f }, { 0.985388f , 0.203178f } },
        { { 0.478470f, -0.500000f, 0.145142f }, { 0.820800f, -0.514200f, 0.249000f }, { 0.979666f , 0.180332f } },
        { { 0.461940f, -0.500000f, 0.191342f }, { 0.792400f, -0.514200f, 0.328200f }, { 0.971731f , 0.158156f } },
        { { 0.440961f, -0.500000f, 0.235698f }, { 0.756400f, -0.514200f, 0.404300f }, { 0.961661f , 0.136865f } },
        { { 0.415735f, -0.500000f, 0.277785f }, { 0.713100f, -0.514200f, 0.476500f }, { 0.949553f , 0.116663f } },
        { { 0.386505f, -0.500000f, 0.317197f }, { 0.663000f, -0.514100f, 0.544100f }, { 0.935522f , 0.097746f } },
        { { 0.353553f, -0.500000f, 0.353553f }, { 0.606500f, -0.514200f, 0.606500f }, { 0.919706f , 0.080294f } },
        { { 0.317197f, -0.500000f, 0.386505f }, { 0.544100f, -0.514200f, 0.663000f }, { 0.902254f , 0.064478f } },
        { { 0.277785f, -0.500000f, 0.415735f }, { 0.476500f, -0.514200f, 0.713100f }, { 0.883337f , 0.050447f } },
        { { 0.235698f, -0.500000f, 0.440961f }, { 0.404300f, -0.514200f, 0.756400f }, { 0.863135f , 0.038339f } },
        { { 0.191342f, -0.500000f, 0.461940f }, { 0.328200f, -0.514200f, 0.792400f }, { 0.841844f , 0.028269f } },
        { { 0.145142f, -0.500000f, 0.478470f }, { 0.249000f, -0.514200f, 0.820800f }, { 0.819668f , 0.020334f } },
        { { 0.097545f, -0.500000f, 0.490393f }, { 0.167300f, -0.514200f, 0.841200f }, { 0.796822f , 0.014612f } },
        { { 0.000000f, -0.500000f, 0.500000f }, { -0.000000f, -0.514200f, 0.857700f }, { 0.750000f , 0.010000f } },
        { { -0.049009f, -0.500000f, 0.497592f }, { -0.084100f, -0.514200f, 0.853600f }, { 0.726476f , 0.011156f } },
        { { -0.097545f, -0.500000f, 0.490393f }, { -0.167300f, -0.514200f, 0.841200f }, { 0.703178f , 0.014612f } },
        { { -0.145142f, -0.500000f, 0.478470f }, { -0.249000f, -0.514200f, 0.820800f }, { 0.680332f , 0.020334f } },
        { { -0.191342f, -0.500000f, 0.461940f }, { -0.328200f, -0.514200f, 0.792400f }, { 0.658156f , 0.028269f } },
        { { -0.235698f, -0.500000f, 0.440961f }, { -0.404300f, -0.514200f, 0.756400f }, { 0.636865f , 0.038339f } },
        { { -0.277785f, -0.500000f, 0.415735f }, { -0.476500f, -0.514200f, 0.713100f }, { 0.616663f , 0.050447f } },
        { { -0.317197f, -0.500000f, 0.386505f }, { -0.544100f, -0.514100f, 0.663000f }, { 0.597746f , 0.064478f } },
        { { -0.353553f, -0.500000f, 0.353553f }, { -0.606500f, -0.514200f, 0.606500f }, { 0.580294f , 0.080294f } },
        { { -0.386505f, -0.500000f, 0.317197f }, { -0.663000f, -0.514200f, 0.544100f }, { 0.564478f , 0.097746f } },
        { { -0.415735f, -0.500000f, 0.277785f }, { -0.713100f, -0.514200f, 0.476500f }, { 0.550447f , 0.116663f } },
        { { -0.440961f, -0.500000f, 0.235698f }, { -0.756400f, -0.514200f, 0.404300f }, { 0.538339f , 0.136865f } },
        { { -0.461940f, -0.500000f, 0.191342f }, { -0.792400f, -0.514200f, 0.328200f }, { 0.528269f , 0.158156f } },
        { { -0.478470f, -0.500000f, 0.145142f }, { -0.820800f, -0.514200f, 0.249000f }, { 0.520334f , 0.180332f } },
        { { -0.490393f, -0.500000f, 0.097545f }, { -0.841200f, -0.514200f, 0.167300f }, { 0.514612f , 0.203178f } },
        { { -0.500000f, -0.500000f, 0.000000f }, { -0.857700f, -0.514200f, -0.000000f }, { 0.510000f , 0.250000f } },
        { { -0.497592f, -0.500000f, -0.049009f }, { -0.853600f, -0.514200f, -0.084100f }, { 0.511156f , 0.273524f } },
        { { -0.490393f, -0.500000f, -0.097545f }, { -0.841200f, -0.514200f, -0.167300f }, { 0.514612f , 0.296822f } },
        { { -0.478470f, -0.500000f, -0.145142f }, { -0.820800f, -0.514200f, -0.249000f }, { 0.520334f , 0.319668f } },
        { { -0.461940f, -0.500000f, -0.191342f }, { -0.792400f, -0.514200f, -0.328200f }, { 0.528269f , 0.341844f } },
        { { -0.440961f, -0.500000f, -0.235698f }, { -0.756400f, -0.514200f, -0.404300f }, { 0.538339f , 0.363135f } },
        { { -0.415735f, -0.500000f, -0.277785f }, { -0.713100f, -0.514200f, -0.476500f }, { 0.550447f , 0.383337f } },
        { { -0.386505f, -0.500000f, -0.317197f }, { -0.663000f, -0.514100f, -0.544100f }, { 0.564478f , 0.402254f } },
        { { -0.353553f, -0.500000f, -0.353553f }, { -0.606500f, -0.514200f, -0.606500f }, { 0.580294f , 0.419706f } },
        { { -0.317197f, -0.500000f, -0.386505f }, { -0.544100f, -0.514200f, -0.663000f }, { 0.597746f , 0.435522f } },
        { { -0.277785f, -0.500000f, -0.415735f }, { -0.476500f, -0.514200f, -0.713100f }, { 0.616663f , 0.449553f } },
        { { -0.235698f, -0.500000f, -0.440961f }, { -0.404300f, -0.514200f, -0.756400f }, { 0.636865f , 0.461661f } },
        { { -0.191342f, -0.500000f, -0.461940f }, { -0.328200f, -0.514200f, -0.792400f }, { 0.658156f , 0.471731f } },
        { { -0.145142f, -0.500000f, -0.478470f }, { -0.249000f, -0.514200f, -0.820800f }, { 0.680332f , 0.479666f } },
        { { -0.097545f, -0.500000f, -0.490393f }, { -0.167300f, -0.514200f, -0.841200f }, { 0.703178f , 0.485388f } },
        };
        MeshIndex indices[]
        {
        0, 1, 2,
        2, 1, 3,
        3, 1, 4,
        4, 1, 5,
        5, 1, 6,
        6, 1, 7,
        7, 1, 8,
        8, 1, 9,
        9, 1, 10,
        10, 1, 11,
        11, 1, 12,
        12, 1, 13,
        13, 1, 14,
        14, 1, 15,
        15, 1, 16,
        16, 1, 17,
        17, 1, 18,
        18, 1, 19,
        19, 1, 20,
        20, 1, 21,
        21, 1, 22,
        22, 1, 23,
        23, 1, 24,
        24, 1, 25,
        25, 1, 26,
        26, 1, 27,
        27, 1, 28,
        28, 1, 29,
        29, 1, 30,
        30, 1, 31,
        31, 1, 32,
        32, 1, 33,
        33, 1, 34,
        34, 1, 35,
        35, 1, 36,
        36, 1, 37,
        37, 1, 38,
        38, 1, 39,
        39, 1, 40,
        40, 1, 41,
        41, 1, 42,
        42, 1, 43,
        43, 1, 44,
        44, 1, 45,
        45, 1, 46,
        46, 1, 47,
        47, 1, 48,
        48, 1, 49,
        49, 1, 50,
        50, 1, 51,
        51, 1, 52,
        52, 1, 53,
        53, 1, 54,
        54, 1, 55,
        55, 1, 56,
        56, 1, 57,
        57, 1, 58,
        58, 1, 59,
        59, 1, 60,
        60, 1, 61,
        61, 1, 62,
        62, 1, 63,
        64, 65, 66,
        63, 1, 67,
        67, 1, 0,
        66, 68, 69,
        69, 70, 71,
        71, 72, 73,
        73, 74, 75,
        75, 76, 77,
        77, 78, 79,
        79, 80, 81,
        81, 82, 83,
        83, 84, 85,
        85, 86, 87,
        87, 88, 89,
        89, 90, 91,
        91, 92, 93,
        93, 94, 95,
        95, 96, 97,
        97, 98, 64,
        64, 99, 100,
        100, 101, 102,
        102, 103, 104,
        104, 105, 106,
        106, 107, 108,
        108, 109, 110,
        110, 111, 112,
        112, 113, 65,
        65, 114, 115,
        115, 116, 117,
        117, 118, 119,
        119, 120, 121,
        121, 122, 123,
        123, 124, 125,
        125, 126, 127,
        127, 128, 66,
        66, 69, 71,
        71, 73, 75,
        75, 77, 79,
        79, 81, 83,
        83, 85, 87,
        87, 89, 91,
        91, 93, 95,
        95, 97, 64,
        64, 100, 102,
        102, 104, 106,
        106, 108, 110,
        110, 112, 65,
        65, 115, 117,
        117, 119, 121,
        121, 123, 125,
        125, 127, 66,
        66, 71, 75,
        75, 79, 83,
        83, 87, 91,
        91, 95, 64,
        64, 102, 106,
        106, 110, 65,
        65, 117, 121,
        121, 125, 66,
        66, 75, 83,
        83, 91, 64,
        64, 106, 65,
        65, 121, 66,
        66, 83, 64,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::ConeNoBase(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
        { { 0.000000f, -0.500000f, -0.500000f }, { -0.000000f, 0.447200f, -0.894400f }, { 0.250000f , 0.490000f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.250000f , 0.250000f } },
        { { 0.049009f, -0.500000f, -0.497592f }, { 0.087700f, 0.447200f, -0.890100f }, { 0.273524f , 0.488844f } },
        { { 0.097545f, -0.500000f, -0.490393f }, { 0.174500f, 0.447200f, -0.877200f }, { 0.296822f , 0.485388f } },
        { { 0.145142f, -0.500000f, -0.478470f }, { 0.259600f, 0.447200f, -0.855900f }, { 0.319668f , 0.479666f } },
        { { 0.191342f, -0.500000f, -0.461940f }, { 0.342300f, 0.447200f, -0.826300f }, { 0.341844f , 0.471731f } },
        { { 0.235698f, -0.500000f, -0.440961f }, { 0.421600f, 0.447200f, -0.788800f }, { 0.363135f , 0.461661f } },
        { { 0.277785f, -0.500000f, -0.415735f }, { 0.496900f, 0.447200f, -0.743700f }, { 0.383337f , 0.449553f } },
        { { 0.317197f, -0.500000f, -0.386505f }, { 0.567400f, 0.447200f, -0.691400f }, { 0.402254f , 0.435522f } },
        { { 0.353553f, -0.500000f, -0.353553f }, { 0.632500f, 0.447200f, -0.632500f }, { 0.419706f , 0.419706f } },
        { { 0.386505f, -0.500000f, -0.317197f }, { 0.691400f, 0.447200f, -0.567400f }, { 0.435522f , 0.402254f } },
        { { 0.415735f, -0.500000f, -0.277785f }, { 0.743700f, 0.447200f, -0.496900f }, { 0.449553f , 0.383337f } },
        { { 0.440961f, -0.500000f, -0.235698f }, { 0.788800f, 0.447200f, -0.421600f }, { 0.461661f , 0.363135f } },
        { { 0.461940f, -0.500000f, -0.191342f }, { 0.826300f, 0.447200f, -0.342300f }, { 0.471731f , 0.341844f } },
        { { 0.478470f, -0.500000f, -0.145142f }, { 0.855900f, 0.447200f, -0.259600f }, { 0.479666f , 0.319668f } },
        { { 0.490393f, -0.500000f, -0.097545f }, { 0.877200f, 0.447200f, -0.174500f }, { 0.485388f , 0.296822f } },
        { { 0.497592f, -0.500000f, -0.049009f }, { 0.890100f, 0.447200f, -0.087700f }, { 0.488844f , 0.273524f } },
        { { 0.500000f, -0.500000f, 0.000000f }, { 0.894400f, 0.447200f, -0.000000f }, { 0.490000f , 0.250000f } },
        { { 0.497592f, -0.500000f, 0.049009f }, { 0.890100f, 0.447200f, 0.087700f }, { 0.488844f , 0.226476f } },
        { { 0.490393f, -0.500000f, 0.097545f }, { 0.877200f, 0.447200f, 0.174500f }, { 0.485388f , 0.203178f } },
        { { 0.478470f, -0.500000f, 0.145142f }, { 0.855900f, 0.447200f, 0.259600f }, { 0.479666f , 0.180332f } },
        { { 0.461940f, -0.500000f, 0.191342f }, { 0.826300f, 0.447200f, 0.342300f }, { 0.471731f , 0.158156f } },
        { { 0.440961f, -0.500000f, 0.235698f }, { 0.788800f, 0.447200f, 0.421600f }, { 0.461661f , 0.136865f } },
        { { 0.415735f, -0.500000f, 0.277785f }, { 0.743700f, 0.447200f, 0.496900f }, { 0.449553f , 0.116663f } },
        { { 0.386505f, -0.500000f, 0.317197f }, { 0.691400f, 0.447200f, 0.567400f }, { 0.435522f , 0.097746f } },
        { { 0.353553f, -0.500000f, 0.353553f }, { 0.632500f, 0.447200f, 0.632500f }, { 0.419706f , 0.080294f } },
        { { 0.317197f, -0.500000f, 0.386505f }, { 0.567400f, 0.447200f, 0.691400f }, { 0.402254f , 0.064478f } },
        { { 0.277785f, -0.500000f, 0.415735f }, { 0.496900f, 0.447200f, 0.743700f }, { 0.383337f , 0.050447f } },
        { { 0.235698f, -0.500000f, 0.440961f }, { 0.421600f, 0.447200f, 0.788800f }, { 0.363135f , 0.038339f } },
        { { 0.191342f, -0.500000f, 0.461940f }, { 0.342300f, 0.447200f, 0.826300f }, { 0.341844f , 0.028269f } },
        { { 0.145142f, -0.500000f, 0.478470f }, { 0.259600f, 0.447200f, 0.855900f }, { 0.319668f , 0.020334f } },
        { { 0.097545f, -0.500000f, 0.490393f }, { 0.174500f, 0.447200f, 0.877200f }, { 0.296822f , 0.014612f } },
        { { 0.049009f, -0.500000f, 0.497592f }, { 0.087700f, 0.447200f, 0.890100f }, { 0.273524f , 0.011156f } },
        { { 0.000000f, -0.500000f, 0.500000f }, { -0.000000f, 0.447200f, 0.894400f }, { 0.250000f , 0.010000f } },
        { { -0.049009f, -0.500000f, 0.497592f }, { -0.087700f, 0.447200f, 0.890100f }, { 0.226476f , 0.011156f } },
        { { -0.097545f, -0.500000f, 0.490393f }, { -0.174500f, 0.447200f, 0.877200f }, { 0.203178f , 0.014612f } },
        { { -0.145142f, -0.500000f, 0.478470f }, { -0.259600f, 0.447200f, 0.855900f }, { 0.180332f , 0.020334f } },
        { { -0.191342f, -0.500000f, 0.461940f }, { -0.342300f, 0.447200f, 0.826300f }, { 0.158156f , 0.028269f } },
        { { -0.235698f, -0.500000f, 0.440961f }, { -0.421600f, 0.447200f, 0.788800f }, { 0.136865f , 0.038339f } },
        { { -0.277785f, -0.500000f, 0.415735f }, { -0.496900f, 0.447200f, 0.743700f }, { 0.116663f , 0.050447f } },
        { { -0.317197f, -0.500000f, 0.386505f }, { -0.567400f, 0.447200f, 0.691400f }, { 0.097746f , 0.064478f } },
        { { -0.353553f, -0.500000f, 0.353553f }, { -0.632500f, 0.447200f, 0.632500f }, { 0.080294f , 0.080294f } },
        { { -0.386505f, -0.500000f, 0.317197f }, { -0.691400f, 0.447200f, 0.567400f }, { 0.064478f , 0.097746f } },
        { { -0.415735f, -0.500000f, 0.277785f }, { -0.743700f, 0.447200f, 0.496900f }, { 0.050447f , 0.116663f } },
        { { -0.440961f, -0.500000f, 0.235698f }, { -0.788800f, 0.447200f, 0.421600f }, { 0.038339f , 0.136865f } },
        { { -0.461940f, -0.500000f, 0.191342f }, { -0.826300f, 0.447200f, 0.342300f }, { 0.028269f , 0.158156f } },
        { { -0.478470f, -0.500000f, 0.145142f }, { -0.855900f, 0.447200f, 0.259600f }, { 0.020334f , 0.180332f } },
        { { -0.490393f, -0.500000f, 0.097545f }, { -0.877200f, 0.447200f, 0.174500f }, { 0.014612f , 0.203178f } },
        { { -0.497592f, -0.500000f, 0.049009f }, { -0.890100f, 0.447200f, 0.087700f }, { 0.011156f , 0.226476f } },
        { { -0.500000f, -0.500000f, 0.000000f }, { -0.894400f, 0.447200f, -0.000000f }, { 0.010000f , 0.250000f } },
        { { -0.497592f, -0.500000f, -0.049009f }, { -0.890100f, 0.447200f, -0.087700f }, { 0.011156f , 0.273524f } },
        { { -0.490393f, -0.500000f, -0.097545f }, { -0.877200f, 0.447200f, -0.174500f }, { 0.014612f , 0.296822f } },
        { { -0.478470f, -0.500000f, -0.145142f }, { -0.855900f, 0.447200f, -0.259600f }, { 0.020334f , 0.319668f } },
        { { -0.461940f, -0.500000f, -0.191342f }, { -0.826300f, 0.447200f, -0.342300f }, { 0.028269f , 0.341844f } },
        { { -0.440961f, -0.500000f, -0.235698f }, { -0.788800f, 0.447200f, -0.421600f }, { 0.038339f , 0.363135f } },
        { { -0.415735f, -0.500000f, -0.277785f }, { -0.743700f, 0.447200f, -0.496900f }, { 0.050447f , 0.383337f } },
        { { -0.386505f, -0.500000f, -0.317197f }, { -0.691400f, 0.447200f, -0.567400f }, { 0.064478f , 0.402254f } },
        { { -0.353553f, -0.500000f, -0.353553f }, { -0.632500f, 0.447200f, -0.632500f }, { 0.080294f , 0.419706f } },
        { { -0.317197f, -0.500000f, -0.386505f }, { -0.567400f, 0.447200f, -0.691400f }, { 0.097746f , 0.435522f } },
        { { -0.277785f, -0.500000f, -0.415735f }, { -0.496900f, 0.447200f, -0.743700f }, { 0.116663f , 0.449553f } },
        { { -0.235698f, -0.500000f, -0.440961f }, { -0.421600f, 0.447200f, -0.788800f }, { 0.136865f , 0.461661f } },
        { { -0.191342f, -0.500000f, -0.461940f }, { -0.342300f, 0.447200f, -0.826300f }, { 0.158156f , 0.471731f } },
        { { -0.145142f, -0.500000f, -0.478470f }, { -0.259600f, 0.447200f, -0.855900f }, { 0.180332f , 0.479666f } },
        { { -0.097545f, -0.500000f, -0.490393f }, { -0.174500f, 0.447200f, -0.877200f }, { 0.203178f , 0.485388f } },
        { { -0.049009f, -0.500000f, -0.497592f }, { -0.087700f, 0.447200f, -0.890100f }, { 0.226476f , 0.488844f } },
        };
        MeshIndex indices[]
        {
        0, 1, 2,
        2, 1, 3,
        3, 1, 4,
        4, 1, 5,
        5, 1, 6,
        6, 1, 7,
        7, 1, 8,
        8, 1, 9,
        9, 1, 10,
        10, 1, 11,
        11, 1, 12,
        12, 1, 13,
        13, 1, 14,
        14, 1, 15,
        15, 1, 16,
        16, 1, 17,
        17, 1, 18,
        18, 1, 19,
        19, 1, 20,
        20, 1, 21,
        21, 1, 22,
        22, 1, 23,
        23, 1, 24,
        24, 1, 25,
        25, 1, 26,
        26, 1, 27,
        27, 1, 28,
        28, 1, 29,
        29, 1, 30,
        30, 1, 31,
        31, 1, 32,
        32, 1, 33,
        33, 1, 34,
        34, 1, 35,
        35, 1, 36,
        36, 1, 37,
        37, 1, 38,
        38, 1, 39,
        39, 1, 40,
        40, 1, 41,
        41, 1, 42,
        42, 1, 43,
        43, 1, 44,
        44, 1, 45,
        45, 1, 46,
        46, 1, 47,
        47, 1, 48,
        48, 1, 49,
        49, 1, 50,
        50, 1, 51,
        51, 1, 52,
        52, 1, 53,
        53, 1, 54,
        54, 1, 55,
        55, 1, 56,
        56, 1, 57,
        57, 1, 58,
        58, 1, 59,
        59, 1, 60,
        60, 1, 61,
        61, 1, 62,
        62, 1, 63,
        63, 1, 64,
        64, 1, 0,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh::Mesh(ID3D11Device* dev, std::span<const MeshVertex> vertices, std::span<const MeshIndex> indices)
        : m_vertices{}
        , m_indices{}
        , m_vertex_count{ static_cast<UINT>(vertices.size()) }
        , m_index_count{ static_cast<UINT>(indices.size()) }

    {
        // upload vertices to the GPU
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = static_cast<UINT>(vertices.size_bytes());
            desc.Usage = D3D11_USAGE_IMMUTABLE;
            desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
            desc.CPUAccessFlags = 0;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            D3D11_SUBRESOURCE_DATA data{};
            data.pSysMem = vertices.data();
            data.SysMemPitch = 0;
            data.SysMemSlicePitch = 0;
            qk_CheckHR(dev->CreateBuffer(&desc, &data, m_vertices.ReleaseAndGetAddressOf()));
        }

        // upload indices to the GPU
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = static_cast<UINT>(indices.size_bytes());
            desc.Usage = D3D11_USAGE_IMMUTABLE;
            desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
            desc.CPUAccessFlags = 0;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            D3D11_SUBRESOURCE_DATA data{};
            data.pSysMem = indices.data();
            data.SysMemPitch = 0;
            data.SysMemSlicePitch = 0;
            qk_CheckHR(dev->CreateBuffer(&desc, &data, m_indices.ReleaseAndGetAddressOf()));
        }
    }

    class Texture
    {
    public:
        static Texture AlbedoBlack(ID3D11Device* dev);
        static Texture AlbedoWhite(ID3D11Device* dev);
        static Texture AlbedoPink(ID3D11Device* dev);
        static Texture AlbedoChecker(ID3D11Device* dev);
    private:
        constexpr static int ALBEDO_DIM{ 64 };
    public:
        Texture(ID3D11Device* dev, bool linear, int w, int h, int channels, const void* data);
        Texture(ID3D11Device* dev, bool linear, std::filesystem::path path);
        ~Texture() = default;
        Texture(const Texture&) = delete;
        Texture(Texture&&) noexcept = default;
        Texture& operator=(const Texture&) = delete;
        Texture& operator=(Texture&&) noexcept = default;
    public:
        ID3D11ShaderResourceView* SRV() const noexcept { return m_srv.Get(); }
    private:
        wrl::ComPtr<ID3D11Texture2D> m_texture;
        wrl::ComPtr<ID3D11ShaderResourceView> m_srv;
    };
    Texture Texture::AlbedoBlack(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int i{}; i < DIM * DIM; i++)
        {
            pixels[i] =
            {
                .r = 0,
                .g = 0,
                .b = 0,
                .a = 0xFF,
            };
        }

        return Texture{ dev, false, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture Texture::AlbedoWhite(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int i{}; i < DIM * DIM; i++)
        {
            pixels[i] =
            {
                .r = 0xFF,
                .g = 0xFF,
                .b = 0xFF,
                .a = 0xFF,
            };
        }

        return Texture{ dev, false, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture Texture::AlbedoPink(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int i{}; i < DIM * DIM; i++)
        {
            pixels[i] =
            {
                .r = 0xFF,
                .g = 0,
                .b = 0xFF,
                .a = 0xFF,
            };
        }

        return Texture{ dev, false, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture Texture::AlbedoChecker(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };
        constexpr int HALF_DIM{ DIM / 2 };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int row{}; row < DIM; row++)
        {
            for (int col{}; col < DIM; col++)
            {
                bool is_less_half_on_row{ row < HALF_DIM };
                bool is_less_half_on_col{ col < HALF_DIM };
                int idx{ row * DIM + col };
                if (is_less_half_on_row != is_less_half_on_col) // logical xor
                {
                    pixels[idx] =
                    {
                        .r = 0,
                        .g = 0,
                        .b = 0,
                        .a = 0xFF,
                    };
                }
                else
                {
                    pixels[idx] =
                    {
                        .r = 0xFF,
                        .g = 0xFF,
                        .b = 0xFF,
                        .a = 0xFF,
                    };
                }
            }
        }

        return Texture{ dev, false, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture::Texture(ID3D11Device* dev, bool linear, int w, int h, int channels, const void* data)
        : m_texture{}
        , m_srv{}
    {
        // upload image data to directxtex scratch image object
        DirectX::ScratchImage image{};
        {
            // choose most appropriate format for the image
            DXGI_FORMAT format{};
            switch (channels)
            {
            case 1: { format = DXGI_FORMAT_R8_UNORM; } break;
            case 2: { format = DXGI_FORMAT_R8G8_UNORM; } break;
            case 4: { format = DXGI_FORMAT_R8G8B8A8_UNORM; } break;
            default: { qk_Unreachable(); } break;
            }

            if (linear) // if image is required to be linear, make sure that the slected format is linear
            {
                format = DirectX::MakeLinear(format);
            }
            else // if image is required to be not-linear, make sure that the slected format is sRGB
            {
                format = DirectX::MakeSRGB(format);
            }

            // initialize image
            qk_CheckHR(image.Initialize2D(format, w, h, 1, 1));
            const DirectX::Image* img{ image.GetImage(0, 0, 0) };

            // copy image row by row, since the row pitch may be different from w * channels
            for (std::size_t row{}; row < img->height; row++)
            {
                std::memcpy(img->pixels + row * img->rowPitch, static_cast<const std::uint8_t*>(data) + row * w * channels, w * channels);
            }
        }

        // generate image mip chain
        DirectX::ScratchImage mip_chain{};
        qk_CheckHR(DirectX::GenerateMipMaps(*image.GetImage(0, 0, 0), DirectX::TEX_FILTER_DEFAULT, 0, mip_chain, false));

        // get texture metadata
        DirectX::TexMetadata metadata{ mip_chain.GetMetadata() };

        // upload image to the GPU
        {
            D3D11_TEXTURE2D_DESC desc{};
            desc.Width = static_cast<UINT>(metadata.width);
            desc.Height = static_cast<UINT>(metadata.height);
            desc.MipLevels = static_cast<UINT>(metadata.mipLevels);
            desc.ArraySize = static_cast<UINT>(metadata.arraySize);
            desc.Format = metadata.format;
            desc.SampleDesc = { .Count = 1, .Quality = 0 };
            desc.Usage = D3D11_USAGE_IMMUTABLE;
            desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
            desc.CPUAccessFlags = 0;
            desc.MiscFlags = 0;

            auto subres_data{ std::make_unique<D3D11_SUBRESOURCE_DATA[]>(metadata.mipLevels) };
            for (std::size_t mip_level{}; mip_level < metadata.mipLevels; mip_level++)
            {
                auto mip_lvl{ mip_chain.GetImage(mip_level, 0, 0) };
                subres_data[mip_level].pSysMem = mip_lvl->pixels;
                subres_data[mip_level].SysMemPitch = static_cast<UINT>(mip_lvl->rowPitch);
                subres_data[mip_level].SysMemSlicePitch = static_cast<UINT>(mip_lvl->slicePitch);
            }

            qk_CheckHR(dev->CreateTexture2D(&desc, subres_data.get(), m_texture.ReleaseAndGetAddressOf()));
        }

        // create srv
        qk_CheckHR(dev->CreateShaderResourceView(m_texture.Get(), nullptr, m_srv.ReleaseAndGetAddressOf()));
    }
    Texture::Texture(ID3D11Device* dev, bool linear, std::filesystem::path path)
        : m_texture{}
        , m_srv{}
    {
        // load texture from file
        DirectX::ScratchImage img{};
        qk_CheckHR(DirectX::LoadFromWICFile(path.wstring().c_str(), DirectX::WIC_FLAGS_NONE, nullptr, img));

        // generate texture mip chain
        DirectX::ScratchImage mip_chain{};
        qk_CheckHR(DirectX::GenerateMipMaps(*img.GetImage(0, 0, 0), DirectX::TEX_FILTER_DEFAULT, 0, mip_chain, false));

        // get texture metadata
        DirectX::TexMetadata metadata{ mip_chain.GetMetadata() };

        // make format linear or sRGB, as required
        if (linear)
        {
            metadata.format = DirectX::MakeLinear(metadata.format);
        }
        else
        {
            metadata.format = DirectX::MakeSRGB(metadata.format);
        }

        // upload image to GPU
        {
            D3D11_TEXTURE2D_DESC desc{};
            desc.Width = static_cast<UINT>(metadata.width);
            desc.Height = static_cast<UINT>(metadata.height);
            desc.MipLevels = static_cast<UINT>(metadata.mipLevels);
            desc.ArraySize = static_cast<UINT>(metadata.arraySize);
            desc.Format = metadata.format;
            desc.SampleDesc = { .Count = 1, .Quality = 0 };
            desc.Usage = D3D11_USAGE_IMMUTABLE;
            desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
            desc.CPUAccessFlags = 0;
            desc.MiscFlags = 0;

            auto subres_data{ std::make_unique<D3D11_SUBRESOURCE_DATA[]>(metadata.mipLevels) };
            for (size_t mip_level{}; mip_level < metadata.mipLevels; mip_level++)
            {
                auto mip_lvl{ mip_chain.GetImage(mip_level, 0, 0) };
                subres_data[mip_level].pSysMem = mip_lvl->pixels;
                subres_data[mip_level].SysMemPitch = static_cast<UINT>(mip_lvl->rowPitch);
                subres_data[mip_level].SysMemSlicePitch = static_cast<UINT>(mip_lvl->slicePitch);
            }

            qk_CheckHR(dev->CreateTexture2D(&desc, subres_data.get(), m_texture.ReleaseAndGetAddressOf()));
        }

        // create srv
        qk_CheckHR(dev->CreateShaderResourceView(m_texture.Get(), nullptr, m_srv.ReleaseAndGetAddressOf()));
    }

    class ObjectPass
    {
    public:
        ObjectPass(ID3D11Device* dev, ID3D11DeviceContext* ctx, const std::vector<Mesh>& meshes, const std::vector<Texture>& textures, d11::SamplerCache& samplers);
        ~ObjectPass() = default;
        ObjectPass(const ObjectPass&) = delete;
        ObjectPass(ObjectPass&&) noexcept = delete;
        ObjectPass& operator=(const ObjectPass&) = delete;
        ObjectPass& operator=(ObjectPass&&) noexcept = delete;
    public:
        void Render(int w, int h, ID3D11RenderTargetView* rtv, ID3D11DepthStencilView* dsv, const Scene& scene);
    private:
        ID3D11Device* m_dev;
        ID3D11DeviceContext* m_ctx;
        const std::vector<Mesh>& m_meshes;
        const std::vector<Texture>& m_textures;
        d11::SamplerCache& m_samplers;
        D3D11_VIEWPORT m_viewport;
        wrl::ComPtr<ID3D11VertexShader> m_vs;
        wrl::ComPtr<ID3D11VertexShader> m_vs_wboit_composite;
        wrl::ComPtr<ID3D11PixelShader> m_ps;
        wrl::ComPtr<ID3D11PixelShader> m_ps_wboit;
        wrl::ComPtr<ID3D11PixelShader> m_ps_wboit_composite;
        wrl::ComPtr<ID3D11InputLayout> m_il;
        wrl::ComPtr<ID3D11RasterizerState> m_rs_fill_cull;
        wrl::ComPtr<ID3D11RasterizerState> m_rs_fill_nocull;
        wrl::ComPtr<ID3D11RasterizerState> m_rs_wireframe;
        wrl::ComPtr<ID3D11DepthStencilState> m_dss_nowrite;
        wrl::ComPtr<ID3D11BlendState> m_bs_over;
        wrl::ComPtr<ID3D11BlendState> m_bs_wboit_accum_reveal;
        wrl::ComPtr<ID3D11BlendState> m_bs_wboit_composit;
        d11::ConstantBuffer m_cb_scene;
        d11::ConstantBuffer m_cb_object;
        d11::StructuredBuffer m_sb_lights;
        d11::Buffer2D m_wboit_accum_buffer;
        d11::Buffer2D m_wboit_reveal_buffer;
        std::vector<Object> m_transparent_objects;
    };
    ObjectPass::ObjectPass(ID3D11Device* dev, ID3D11DeviceContext* ctx, const std::vector<Mesh>& meshes, const std::vector<Texture>& textures, d11::SamplerCache& samplers)
        : m_dev{ dev }
        , m_ctx{ ctx }
        , m_meshes{ meshes }
        , m_textures{ textures }
        , m_samplers{ samplers }
        , m_viewport{ .TopLeftX = 0.0f, .TopLeftY = 0.0f, .MinDepth = 0.0f, .MaxDepth = 1.0f }
        , m_vs{}
        , m_vs_wboit_composite{}
        , m_ps{}
        , m_ps_wboit{}
        , m_ps_wboit_composite{}
        , m_il{}
        , m_rs_fill_cull{}
        , m_rs_fill_nocull{}
        , m_rs_wireframe{}
        , m_dss_nowrite{}
        , m_bs_over{}
        , m_bs_wboit_accum_reveal{}
        , m_bs_wboit_composit{}
        , m_cb_scene{}
        , m_cb_object{}
        , m_sb_lights{ dev, sizeof(ObjectPassLight) }
        , m_wboit_accum_buffer{ dev, DXGI_FORMAT_R16G16B16A16_FLOAT, D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET }
        , m_wboit_reveal_buffer{ dev, DXGI_FORMAT_R16_FLOAT, D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET }
        , m_transparent_objects{}
    {
        #include <qk/hlsl/ObjectPassVS.h>
        #include <qk/hlsl/WBOITCompositeVS.h>
        #include <qk/hlsl/ObjectPassPS.h>
        #include <qk/hlsl/ObjectPassWBOITPS.h>
        #include <qk/hlsl/WBOITCompositePS.h>

        // vertex shader
        qk_CheckHR(m_dev->CreateVertexShader(ObjectPassVS_bytes, sizeof(ObjectPassVS_bytes), nullptr, m_vs.ReleaseAndGetAddressOf()));

        // vertex shader for wboit composite pass
        qk_CheckHR(m_dev->CreateVertexShader(WBOITCompositeVS_bytes, sizeof(WBOITCompositeVS_bytes), nullptr, m_vs_wboit_composite.ReleaseAndGetAddressOf()));

        // pixel shader
        qk_CheckHR(m_dev->CreatePixelShader(ObjectPassPS_bytes, sizeof(ObjectPassPS_bytes), nullptr, m_ps.ReleaseAndGetAddressOf()));

        // pixel shader for wboit
        qk_CheckHR(m_dev->CreatePixelShader(ObjectPassWBOITPS_bytes, sizeof(ObjectPassWBOITPS_bytes), nullptr, m_ps_wboit.ReleaseAndGetAddressOf()));

        // pixel shader for wboit composite pass
        qk_CheckHR(m_dev->CreatePixelShader(WBOITCompositePS_bytes, sizeof(WBOITCompositePS_bytes), nullptr, m_ps_wboit_composite.ReleaseAndGetAddressOf()));

        // input layout
        {
            D3D11_INPUT_ELEMENT_DESC desc[] =
            {
                { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
                { "NORMAL",   0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
                { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,    0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
            };
            qk_CheckHR(m_dev->CreateInputLayout(desc, std::size(desc), ObjectPassVS_bytes, sizeof(ObjectPassVS_bytes), m_il.ReleaseAndGetAddressOf()));
        }

        // rasterizer state: backeface culling, counter-clockwise is front-face
        {
            D3D11_RASTERIZER_DESC desc{};
            desc.FillMode = D3D11_FILL_SOLID;
            desc.CullMode = D3D11_CULL_BACK;
            desc.FrontCounterClockwise = true;
            desc.DepthClipEnable = true;
            qk_CheckHR(m_dev->CreateRasterizerState(&desc, m_rs_fill_cull.ReleaseAndGetAddressOf()));
        }

        // rasterizer state: no backface culling
        {
            D3D11_RASTERIZER_DESC desc{};
            desc.FillMode = D3D11_FILL_SOLID;
            desc.CullMode = D3D11_CULL_NONE;
            desc.FrontCounterClockwise = true;
            desc.DepthClipEnable = true;
            qk_CheckHR(m_dev->CreateRasterizerState(&desc, m_rs_fill_nocull.ReleaseAndGetAddressOf()));
        }

        // wireframe rasterizer state
        {
            D3D11_RASTERIZER_DESC desc{};
            desc.FillMode = D3D11_FILL_WIREFRAME;
            desc.CullMode = D3D11_CULL_NONE;
            desc.FrontCounterClockwise = true;
            desc.DepthBias = 0;
            desc.DepthBiasClamp = 0.0f;
            desc.SlopeScaledDepthBias = 0.0f;
            desc.DepthClipEnable = true;
            desc.ScissorEnable = false;
            desc.MultisampleEnable = false;
            desc.AntialiasedLineEnable = false;
            qk_CheckHR(m_dev->CreateRasterizerState(&desc, m_rs_wireframe.ReleaseAndGetAddressOf()));
        }

        // blend state implementing the 'over' operator
        {
            D3D11_BLEND_DESC desc{};
            desc.AlphaToCoverageEnable = false;
            desc.IndependentBlendEnable = false;
            desc.RenderTarget[0].BlendEnable = true;
            desc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
            desc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
            desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ZERO;
            desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ONE;
            desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
            qk_CheckHR(m_dev->CreateBlendState(&desc, m_bs_over.ReleaseAndGetAddressOf()));
        }

        // blend state for the first pass of weighted blended oit
        {
            D3D11_BLEND_DESC desc{};
            desc.AlphaToCoverageEnable = false;
            desc.IndependentBlendEnable = true;
            // blend state for wboit accum buffer
            desc.RenderTarget[0].BlendEnable = true;
            desc.RenderTarget[0].SrcBlend = D3D11_BLEND_ONE;
            desc.RenderTarget[0].DestBlend = D3D11_BLEND_ONE;
            desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
            desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ONE;
            desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
            // blend state for wboit reveal buffer
            desc.RenderTarget[1].BlendEnable = true;
            desc.RenderTarget[1].SrcBlend = D3D11_BLEND_ZERO;
            desc.RenderTarget[1].DestBlend = D3D11_BLEND_INV_SRC_COLOR;
            desc.RenderTarget[1].BlendOp = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[1].SrcBlendAlpha = D3D11_BLEND_ZERO;
            desc.RenderTarget[1].DestBlendAlpha = D3D11_BLEND_ZERO;
            desc.RenderTarget[1].BlendOpAlpha = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[1].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
            qk_CheckHR(m_dev->CreateBlendState(&desc, m_bs_wboit_accum_reveal.ReleaseAndGetAddressOf()));
        }

        // blend state for the composite pass of wboit
        {
            D3D11_BLEND_DESC desc{};
            desc.AlphaToCoverageEnable = false;
            desc.IndependentBlendEnable = false;
            desc.RenderTarget[0].BlendEnable = true;
            desc.RenderTarget[0].SrcBlend = D3D11_BLEND_INV_SRC_ALPHA;
            desc.RenderTarget[0].DestBlend = D3D11_BLEND_SRC_ALPHA;
            desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ZERO;
            desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ONE;
            desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
            desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
            qk_CheckHR(m_dev->CreateBlendState(&desc, m_bs_wboit_composit.ReleaseAndGetAddressOf()));
        }

        // depth stencil state (perform depth testing but disable writes to the depth buffer)
        {
            D3D11_DEPTH_STENCIL_DESC desc{};
            desc.DepthEnable = true;
            desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO; // turn off writes
            desc.DepthFunc = D3D11_COMPARISON_LESS;
            qk_CheckHR(m_dev->CreateDepthStencilState(&desc, m_dss_nowrite.ReleaseAndGetAddressOf()));
        }

        // scene constant buffer
        m_cb_scene = d11::ConstantBuffer{ m_dev, sizeof(ObjectPassSceneConstants) };

        // object constant buffer
        m_cb_object = d11::ConstantBuffer{ m_dev,sizeof(ObjectPassObjectConstants) };
    }
    void ObjectPass::Render(int w, int h, ID3D11RenderTargetView* rtv, ID3D11DepthStencilView* dsv, const Scene& scene)
    {
        switch (scene.settings.transparency)
        {
        case SceneTransparencyTechnique::Sorted:
        {
            m_wboit_accum_buffer.Free();
            m_wboit_reveal_buffer.Free();
        } break;
        case SceneTransparencyTechnique::WeightedBlendedOIT:
        {
            m_wboit_accum_buffer.Resize(w, h);
            m_wboit_reveal_buffer.Resize(w, h);
        } break;
        default:
        {
            qk_Unreachable();
        } break;
        }

        // upload scene constants
        {
            float aspect{ m_viewport.Width / m_viewport.Height };
            float fov_rad{ DirectX::XMConvertToRadians(scene.camera.fov_deg) };
            Matrix view{ Matrix::CreateLookAt(scene.camera.eye, scene.camera.target, scene.camera.up) };
            Matrix projection{ Matrix::CreatePerspectiveFieldOfView(fov_rad, aspect, scene.camera.near_plane, scene.camera.far_plane) };

            d11::SubresourceMap map{ m_cb_scene.Map(D3D11_MAP_WRITE_DISCARD) };
            auto constants{ map.Data<ObjectPassSceneConstants>() };
            constants->view = view;
            constants->projection = projection;
            constants->lights_count = static_cast<std::int32_t>(scene.lights.size());
        }

        // resize lights structured buffer, if necessary
        // TODO: why not GrowToFit? only resize if the new size is bigger than the current size
        m_sb_lights.Resize(static_cast<UINT>(scene.lights.size() * sizeof(ObjectPassLight)));

        // upload lights
        if (m_sb_lights)
        {
            d11::SubresourceMap map{ m_sb_lights.Map(D3D11_MAP_WRITE_DISCARD) };
            auto constants{ map.Data<ObjectPassLight>() };

            for (std::size_t i{}; i < scene.lights.size(); i++)
            {
                const Light& light{ scene.lights[i] };

                switch (light.type)
                {
                case LightType::Directional: { constants[i].type = QK_OBJECT_PASS_LIGHT_DIRECTIONAL; } break;
                case LightType::Point: { constants[i].type = QK_OBJECT_PASS_LIGHT_POINT; } break;
                case LightType::Spot: { constants[i].type = QK_OBJECT_PASS_LIGHT_SPOT; } break;
                default: { qk_Unreachable(); } break;
                }

                constants[i].world_position = light.position;
                constants[i].direction = light.direction;
                constants[i].color = GammaCorrectToLinear(light.color);
                constants[i].r_min = light.r_min;
                constants[i].r_max = light.r_max;
                constants[i].umbra_rad = dx::XMConvertToRadians(light.umbra_angle_deg);
                constants[i].penumbra_rad = dx::XMConvertToRadians(light.penumbra_angle_deg);
            }
        }

        // set new viewport data
        m_viewport.Width = static_cast<float>(w);
        m_viewport.Height = static_cast<float>(h);

        // render opaque objects
        {
            // prepare pipeline for drawing
            {
                ID3D11Buffer* cbufs[]{ m_cb_scene.Get(), m_cb_object.Get() };

                m_ctx->ClearState();
                m_ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
                m_ctx->IASetInputLayout(m_il.Get());
                m_ctx->VSSetShader(m_vs.Get(), nullptr, 0);
                m_ctx->VSSetConstantBuffers(0, std::size(cbufs), cbufs);
                m_ctx->PSSetShader(m_ps.Get(), nullptr, 0);
                m_ctx->PSSetConstantBuffers(0, std::size(cbufs), cbufs);
                m_ctx->RSSetState(m_rs_fill_cull.Get());
                m_ctx->RSSetViewports(1, &m_viewport);
                m_ctx->OMSetRenderTargets(1, &rtv, dsv);
            }

            // loop over each object node and render it
            for (const Object& object : scene.objects)
            {
                // if the object is not fully opauqe, skip it
                if (object.opacity != 1.0f)
                {
                    continue;
                }

                // compute object's model and normal matrices, then upload them to the GPU
                {
                    Vector3 rotation_rad{};
                    rotation_rad.x = DirectX::XMConvertToRadians(object.rotation.x);
                    rotation_rad.y = DirectX::XMConvertToRadians(object.rotation.y);
                    rotation_rad.z = DirectX::XMConvertToRadians(object.rotation.z);

                    Matrix translate{ Matrix::CreateTranslation(object.position) };
                    Matrix rotate{ Matrix::CreateFromYawPitchRoll(rotation_rad) };
                    Matrix scale{ Matrix::CreateScale(object.scaling) };
                    Matrix model{ scale * rotate * translate };
                    Matrix normal{ scale * rotate };
                    normal.Invert();
                    normal.Transpose();

                    d11::SubresourceMap map{ m_cb_object.Map(D3D11_MAP_WRITE_DISCARD) };
                    auto constants{ map.Data<ObjectPassObjectConstants>() };
                    switch (object.shading_mode)
                    {
                    case ShadingMode::Flat: { constants->shading_mode = QK_OBJECT_PASS_SHADING_MODE_FLAT; } break;
                    case ShadingMode::Shaded: { constants->shading_mode = QK_OBJECT_PASS_SHADING_MODE_SHADED; } break;
                    default: { qk_Unreachable(); } break;
                    }
                    constants->model = model;
                    constants->normal = normal;
                    constants->albedo_color = GammaCorrectToLinear(object.albedo.color);
                    constants->albedo_mix = object.albedo.mix;
                    constants->opacity = object.opacity;
                }

                // set mesh related pipeline state and submit draw call
                {
                    // fetch mesh
                    const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(object.mesh_id)) };

                    // fetch albedo
                    const Texture& albedo{ m_textures.at(static_cast<std::size_t>(object.albedo.id)) };

                    // prepare mesh related data for pipeline state
                    ID3D11Buffer* vertices{ mesh.Vertices() };
                    UINT vertex_stride{ sizeof(MeshVertex) };
                    UINT vertex_offset{};

                    // prepare samplers
                    ID3D11SamplerState* sss[1]{}; // TODO: hardcoded number of samples
                    {
                        sss[0] = m_samplers.Get(GetD3D11SamplerDescFromSampler(object.albedo.sampler));
                    }

                    // prepare shader resource views
                    ID3D11ShaderResourceView* srvs[]{ albedo.SRV(), m_sb_lights.SRV() };

                    // set pipeline state
                    m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                    m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                    m_ctx->PSSetSamplers(0, std::size(sss), sss);
                    m_ctx->PSSetShaderResources(0, std::size(srvs), srvs);

                    // draw
                    m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
                }
            }
        }

        // render opaque gizmos
        {
            // prepare pipeline for drawing
            {
                ID3D11Buffer* cbufs[]{ m_cb_scene.Get(), m_cb_object.Get() };
                ID3D11SamplerState* sss[1]{}; // TODO: this is useful for shutting up warnings // TODO: also hardcoded length
                {
                    D3D11_SAMPLER_DESC desc{};
                    desc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
                    desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
                    desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
                    desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
                    desc.MinLOD = 0.0f;
                    desc.MaxLOD = D3D11_FLOAT32_MAX;
                    sss[0] = m_samplers.Get(desc);
                }
                ID3D11ShaderResourceView* srvs[]{ m_textures.at(static_cast<size_t>(ALBEDO_BLACK)).SRV(), m_sb_lights.SRV(), }; // TODO: this is useful for shutting up warnings

                // set pipeline state
                m_ctx->ClearState();
                m_ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
                m_ctx->IASetInputLayout(m_il.Get());
                m_ctx->VSSetShader(m_vs.Get(), nullptr, 0);
                m_ctx->VSSetConstantBuffers(0, std::size(cbufs), cbufs);
                m_ctx->PSSetShader(m_ps.Get(), nullptr, 0);
                m_ctx->PSSetConstantBuffers(0, std::size(cbufs), cbufs);
                m_ctx->PSSetSamplers(0, std::size(sss), sss);          // TODO: only useful for shutting up warnings
                m_ctx->PSSetShaderResources(0, std::size(srvs), srvs); // TODO: only useful for shutting up warnings
                m_ctx->RSSetState(m_rs_wireframe.Get());
                m_ctx->RSSetViewports(1, &m_viewport);
                m_ctx->OMSetRenderTargets(1, &rtv, dsv);
            }

            // render point lights
            {
                // use icosphere mesh as point light gizmo
                const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(ICOSPHERE)) };

                // set point light related pipeline state
                {
                    // prepare mesh related data for pipeline state
                    ID3D11Buffer* vertices{ mesh.Vertices() };
                    UINT vertex_stride{ sizeof(MeshVertex) };
                    UINT vertex_offset{};

                    // set pipeline state
                    m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                    m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                    m_ctx->RSSetState(m_rs_wireframe.Get());
                }

                for (const Light& light : scene.lights)
                {
                    if (light.type != LightType::Point || !light.render_gizmos) continue;

                    // upload light source object constants
                    {
                        float diameter{ light.r_min * 2.0f };

                        Matrix translate{ Matrix::CreateTranslation(light.position) };
                        Matrix scale{ Matrix::CreateScale(Vector3{ diameter, diameter, diameter }) };
                        Matrix model{ scale * translate };

                        d11::SubresourceMap map{ m_cb_object.Map(D3D11_MAP_WRITE_DISCARD) };
                        auto constants{ map.Data<ObjectPassObjectConstants>() };
                        constants->shading_mode = QK_OBJECT_PASS_SHADING_MODE_FLAT;
                        constants->model = model;
                        constants->albedo_color = GammaCorrectToLinear(light.color);
                        constants->albedo_mix = 0.0f;
                        constants->opacity = 1.0f;
                    }

                    // draw light source gizmo
                    m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);

                    // upload light volume object constants
                    {
                        float diameter{ light.r_max * 2.0f };

                        Matrix translate{ Matrix::CreateTranslation(light.position) };
                        Matrix scale{ Matrix::CreateScale(Vector3{ diameter, diameter, diameter }) };
                        Matrix model{ scale * translate };

                        d11::SubresourceMap map{ m_cb_object.Map(D3D11_MAP_WRITE_DISCARD) };
                        auto constants{ map.Data<ObjectPassObjectConstants>() };
                        constants->shading_mode = QK_OBJECT_PASS_SHADING_MODE_FLAT;
                        constants->model = model;
                        constants->albedo_color = GammaCorrectToLinear(light.color);
                        constants->albedo_mix = 0.0f;
                        constants->opacity = 1.0f;
                    }

                    // draw light source gizmo
                    m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
                }
            }

            // render spot lights
            {
                // use cone mesh as spot light gizmo
                const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(CONE_NO_BASE)) };

                // set spot light related pipeline state
                {
                    // prepare mesh related data for pipeline state
                    ID3D11Buffer* vertices{ mesh.Vertices() };
                    UINT vertex_stride{ sizeof(MeshVertex) };
                    UINT vertex_offset{};

                    // set pipeline state
                    m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                    m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                    m_ctx->RSSetState(m_rs_wireframe.Get());
                }

                for (const Light& light : scene.lights)
                {
                    if (light.type != LightType::Spot || !light.render_gizmos) continue;

                    // for each spot light we render three cones: umbra, penumbra and near
                    constexpr int COUNT{ 3 };

                    // cones angles
                    // TODO: if we draw both umbra and penumbra cones, use the umbra cone angle as the near cone angle,
                    // TODO: if we draw just one of the two cones, use as near cone angle the angle of the cone we are drawing
                    float angles_deg[COUNT]{ light.umbra_angle_deg, light.penumbra_angle_deg, light.umbra_angle_deg };

                    // convert umbra and penumbra angles to radians
                    float angles_rad[COUNT]{};
                    for (int i{}; i < COUNT; i++)
                    {
                        angles_rad[i] = dx::XMConvertToRadians(angles_deg[i]);
                    }

                    // y scaling factors for each cone
                    float y_scales[COUNT]{ light.r_max, light.r_max, light.r_min };

                    // compute x and z scaling factors for each cone
                    float xz_scales[COUNT]{};
                    for (int i{}; i < COUNT; i++)
                    {
                        xz_scales[i] = 2.0f * y_scales[i] * std::tan(angles_rad[i]);
                    }

                    // render umbra and penumbra light volumes
                    for (int i{}; i < COUNT; i++)
                    {
                        // upload light volume object constants
                        {
                            // move cone local space origin to cone peak
                            Matrix translate_0{ Matrix::CreateTranslation(Vector3{ 0.0f, -0.5f, 0.0f }) };
                            // translate cone peak to specified position
                            Matrix translate_1{ Matrix::CreateTranslation(light.position) };
                            Matrix rotate{};
                            {
                                Vector3 direction{ light.direction };
                                direction.Normalize();
                                Vector3 down{ 0.0f, -1.0f, 0.0f }; // local space cone's direction

                                // check wheter direction and down have the same direction
                                float dot{ direction.Dot(down) };
                                if (dot == 1.0f) // they do; no need to rotate
                                {
                                    // do nothing
                                }
                                else // they don't
                                {
                                    // compute rotation axis for rotating down into direction
                                    Vector3 axis{};
                                    if (dot == -1.0f) // direction and down have opposite directions; corss won't work
                                    {
                                        // as rotation axis we pick any vector orthogonal to direction
                                        if (direction.x == 0.0f)
                                        {
                                            axis.y = -direction.z;
                                            axis.z = direction.y;
                                        }
                                        else if (direction.y == 0.0f)
                                        {
                                            axis.x = -direction.z;
                                            axis.z = direction.x;
                                        }
                                        else
                                        {
                                            axis.x = -direction.y;
                                            axis.y = direction.x;
                                        }
                                    }
                                    else // cross will work
                                    {
                                        axis = down.Cross(direction);
                                    }

                                    // compute rotation angle for rotating down into direction
                                    float angle{ std::acos(dot) };

                                    // compute rotation matrix
                                    rotate = Matrix::CreateFromAxisAngle(axis, angle);
                                }
                            }
                            Matrix scale{ Matrix::CreateScale(Vector3{ xz_scales[i], y_scales[i], xz_scales[i]}) };
                            Matrix model{ translate_0 * scale * rotate * translate_1 };

                            d11::SubresourceMap map{ m_cb_object.Map(D3D11_MAP_WRITE_DISCARD) };
                            auto constants{ map.Data<ObjectPassObjectConstants>() };
                            constants->shading_mode = QK_OBJECT_PASS_SHADING_MODE_FLAT;
                            constants->model = model;
                            constants->albedo_color = GammaCorrectToLinear(light.color);
                            constants->albedo_mix = 0.0f;
                            constants->opacity = 1.0f;
                        }

                        // draw gizmo
                        m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
                    }
                }
            }
        }

        // render transparent objects
        {
            // prepare pipeline state
            {
                ID3D11Buffer* cbufs[]{ m_cb_scene.Get(), m_cb_object.Get() };

                m_ctx->ClearState();
                m_ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
                m_ctx->IASetInputLayout(m_il.Get());
                m_ctx->VSSetShader(m_vs.Get(), nullptr, 0);
                m_ctx->VSSetConstantBuffers(0, std::size(cbufs), cbufs);
                m_ctx->PSSetConstantBuffers(0, std::size(cbufs), cbufs);
                m_ctx->RSSetState(m_rs_fill_cull.Get());
                m_ctx->RSSetViewports(1, &m_viewport);
                m_ctx->OMSetDepthStencilState(m_dss_nowrite.Get(), 0);

                switch (scene.settings.transparency)
                {
                case SceneTransparencyTechnique::Sorted:
                {
                    m_ctx->PSSetShader(m_ps.Get(), nullptr, 0);
                    m_ctx->OMSetRenderTargets(1, &rtv, dsv);
                    m_ctx->OMSetBlendState(m_bs_over.Get(), nullptr, 0XFFFFFFFF);
                } break;
                case SceneTransparencyTechnique::WeightedBlendedOIT:
                {
                    ID3D11RenderTargetView* rtvs[]{ m_wboit_accum_buffer.RTV(), m_wboit_reveal_buffer.RTV() };

                    // clear accum buffer
                    {
                        float clear_color[4]{ 0.0f, 0.0f, 0.0f, 0.0f };
                        m_ctx->ClearRenderTargetView(m_wboit_accum_buffer.RTV(), clear_color);
                    }
                    // clear reveal buffer
                    {
                        float clear_color[4]{ 1.0f, 0.0f, 0.0f, 0.0f };
                        m_ctx->ClearRenderTargetView(m_wboit_reveal_buffer.RTV(), clear_color);
                    }

                    m_ctx->PSSetShader(m_ps_wboit.Get(), nullptr, 0);
                    m_ctx->OMSetRenderTargets(std::size(rtvs), rtvs, dsv);
                    m_ctx->OMSetBlendState(m_bs_wboit_accum_reveal.Get(), nullptr, 0XFFFFFFFF);
                } break;
                default:
                {
                    qk_Unreachable();
                } break;
                }
            }

            m_transparent_objects.clear(); // clear previously stored opauqe objects

            // fetch all objects that are neither fully opaque nor fully transparent
            for (const Object& obj : scene.objects)
            {
                if (0.0f < obj.opacity && obj.opacity < 1.0f)
                {
                    m_transparent_objects.emplace_back(obj);
                }
            }

            // sort transparent objects, if required
            if (scene.settings.transparency == SceneTransparencyTechnique::Sorted)
            {
                // sorting back to front means that the one further from the camera should be rendered first (is "greater" than the other object)
                auto cmp{ [&](const Object& a, const Object& b)
                {
                        Vector3 e{ scene.camera.eye };
                        Vector3 p{ a.position };
                        Vector3 q{ b.position };
                        Vector3 e_to_p{ p - e };
                        Vector3 e_to_q{ q - e };
                        return e_to_p.Dot(e_to_p) > e_to_q.Dot(e_to_q); // compare the squared distances
                } };

                // sort the objects back to front
                std::sort(m_transparent_objects.begin(), m_transparent_objects.end(), cmp);
            }

            // loop over each transparent object  and render it
            for (const Object& object : m_transparent_objects)
            {
                // if either the object is fully opauqe or fully transparent, skip it
                if (object.opacity == 1.0f || object.opacity == 0.0f)
                {
                    // TODO: use logger
                    std::cout << "[WARNING]: rendering a fully " << ((object.opacity == 1.0f) ? "opaque" : "transparent") << " object\n";
                    continue;
                }

                // compute object's model and normal matrices, then upload them to the GPU
                {
                    Vector3 rotation_rad{};
                    rotation_rad.x = DirectX::XMConvertToRadians(object.rotation.x);
                    rotation_rad.y = DirectX::XMConvertToRadians(object.rotation.y);
                    rotation_rad.z = DirectX::XMConvertToRadians(object.rotation.z);

                    Matrix translate{ Matrix::CreateTranslation(object.position) };
                    Matrix rotate{ Matrix::CreateFromYawPitchRoll(rotation_rad) };
                    Matrix scale{ Matrix::CreateScale(object.scaling) };
                    Matrix model{ scale * rotate * translate };
                    Matrix normal{ scale * rotate };
                    normal.Invert();
                    normal.Transpose();

                    d11::SubresourceMap map{ m_cb_object.Map(D3D11_MAP_WRITE_DISCARD) };
                    auto constants{ map.Data<ObjectPassObjectConstants>() };
                    switch (object.shading_mode)
                    {
                    case ShadingMode::Flat: { constants->shading_mode = QK_OBJECT_PASS_SHADING_MODE_FLAT; } break;
                    case ShadingMode::Shaded: { constants->shading_mode = QK_OBJECT_PASS_SHADING_MODE_SHADED; } break;
                    default: { qk_Unreachable(); } break;
                    }
                    constants->model = model;
                    constants->normal = normal;
                    constants->albedo_color = GammaCorrectToLinear(object.albedo.color);
                    constants->albedo_mix = object.albedo.mix;
                    constants->opacity = object.opacity;
                }

                // set mesh related pipeline state and submit draw call
                {
                    // fetch mesh
                    const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(object.mesh_id)) };

                    // fetch albedo
                    const Texture& albedo{ m_textures.at(static_cast<std::size_t>(object.albedo.id)) };

                    // prepare mesh related data for pipeline state
                    ID3D11Buffer* vertices{ mesh.Vertices() };
                    UINT vertex_stride{ sizeof(MeshVertex) };
                    UINT vertex_offset{};

                    // prepare samplers
                    ID3D11SamplerState* sss[1]{}; // TODO: hardcoded number of samples
                    {
                        sss[0] = m_samplers.Get(GetD3D11SamplerDescFromSampler(object.albedo.sampler));
                    }

                    // prepare shader resource views
                    ID3D11ShaderResourceView* srvs[]{ albedo.SRV(), m_sb_lights.SRV() };

                    // set pipeline state
                    m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                    m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                    m_ctx->PSSetSamplers(0, std::size(sss), sss);
                    m_ctx->PSSetShaderResources(0, std::size(srvs), srvs);

                    // draw
                    m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
                }
            }

            // if doing weighted blended OIT, we need to composite the result of the transparency pass with the opauqe buffer
            if (scene.settings.transparency == SceneTransparencyTechnique::WeightedBlendedOIT)
            {
                // prepare pipeline state and draw
                {
                    // fetch quad mesh
                    const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(QUAD)) };

                    // prepare mesh related data for pipeline state
                    ID3D11Buffer* vertices{ mesh.Vertices() };
                    UINT vertex_stride{ sizeof(MeshVertex) };
                    UINT vertex_offset{};

                    // prepare samplers
                    ID3D11SamplerState* ss{};
                    {
                        D3D11_SAMPLER_DESC desc{};
                        desc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
                        desc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
                        desc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
                        desc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP; // NOTE: needed to not crash
                        desc.MinLOD = 0;
                        desc.MaxLOD = D3D11_FLOAT32_MAX;
                        ss = m_samplers.Get(desc);
                    }

                    // prepare shader resource views
                    ID3D11ShaderResourceView* srvs[]{ m_wboit_accum_buffer.SRV(), m_wboit_reveal_buffer.SRV() };

                    m_ctx->ClearState();
                    m_ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
                    m_ctx->IASetInputLayout(m_il.Get());
                    m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                    m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                    m_ctx->VSSetShader(m_vs_wboit_composite.Get(), nullptr, 0);
                    m_ctx->PSSetShader(m_ps_wboit_composite.Get(), nullptr, 0);
                    m_ctx->PSSetSamplers(0, 1, &ss);
                    m_ctx->PSSetShaderResources(0, std::size(srvs), srvs);
                    m_ctx->RSSetState(m_rs_fill_cull.Get());
                    m_ctx->RSSetViewports(1, &m_viewport);
                    m_ctx->OMSetRenderTargets(1, &rtv, nullptr);
                    m_ctx->OMSetBlendState(m_bs_wboit_composit.Get(), nullptr, 0XFFFFFFFF);

                    // draw
                    m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
                }
            }
        }
    }

    class RendererImpl
    {
    public:
        RendererImpl(ID3D11Device* dev, ID3D11DeviceContext* ctx);
        ~RendererImpl() = default;
        RendererImpl(const RendererImpl&) = delete;
        RendererImpl(RendererImpl&&) noexcept = delete;
        RendererImpl& operator=(const RendererImpl&) = delete;
        RendererImpl& operator=(RendererImpl&&) noexcept = delete;
    public:
        TextureID LoadTexture(const std::filesystem::path& path, bool linear);
    public:
        void Render(int w, int h, ID3D11RenderTargetView* rtv, const Scene& scene);
    private:
        ID3D11Device* m_dev;
        ID3D11DeviceContext* m_ctx;
        std::vector<Mesh> m_meshes;
        std::vector<Texture> m_textures;
        d11::DepthStencilBuffer m_depth_stencil_buffer;
        d11::SamplerCache m_samplers;
        ObjectPass m_object_pass;
    };

    RendererImpl::RendererImpl(ID3D11Device* dev, ID3D11DeviceContext* ctx)
        : m_dev{ dev }
        , m_ctx{ ctx }
        , m_meshes{}
        , m_textures{}
        , m_depth_stencil_buffer{ m_dev, DXGI_FORMAT_D32_FLOAT } // TODO: hardcoded format
        , m_samplers{ dev }
        , m_object_pass{ m_dev, m_ctx, m_meshes, m_textures, m_samplers }
    {
        // upload default meshes
        // TODO: make it less boilerplaty
        {
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Cube(m_dev));
                qk_Check(MeshID{ idx } == CUBE); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Quad(m_dev));
                qk_Check(MeshID{ idx } == QUAD); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Icosphere(m_dev));
                qk_Check(MeshID{ idx } == ICOSPHERE); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Cone(m_dev));
                qk_Check(MeshID{ idx } == CONE); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::ConeNoBase(m_dev));
                qk_Check(MeshID{ idx } == CONE_NO_BASE); // check that the mesh index matches its predefined id
            }
        }
        // upload ddefault textures
        // TODO: make it less boilerplaty
        {
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoBlack(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_BLACK); // check that the texture index matches its predefined id
            }
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoWhite(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_WHITE); // check that the texture index matches its predefined id
            }
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoPink(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_PINK); // check that the texture index matches its predefined id
            }
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoChecker(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_CHECKER); // check that the texture index matches its predefined id
            }
        }
    }
    TextureID RendererImpl::LoadTexture(const std::filesystem::path& path, bool linear)
    {
        std::size_t idx{ m_textures.size() };
        m_textures.emplace_back(Texture{ m_dev, linear, path });
        return TextureID{ idx };
    }
    void RendererImpl::Render(int w, int h, ID3D11RenderTargetView* rtv, const Scene& scene)
    {
        // resize depth stencil buffer, if necessary
        m_depth_stencil_buffer.Resize(static_cast<UINT>(w), static_cast<UINT>(h));

        // clear rtv using the specified background
        {
            Vector3 color{ scene.background.color };
            color = GammaCorrectToLinear(color);
            float clear_color[4]{ color.x, color.y, color.z, 1.0f };
            m_ctx->ClearRenderTargetView(rtv, clear_color);
        }

        // clear dsv
        m_ctx->ClearDepthStencilView(m_depth_stencil_buffer.DSV(), D3D11_CLEAR_DEPTH, 1.0f, 0);

        // run render passes
        m_object_pass.Render(w, h, rtv, m_depth_stencil_buffer.DSV(), scene);
    }

    Renderer::Renderer(void* d3d_dev, void* d3d_ctx)
        : m_impl{ std::make_shared<RendererImpl>(static_cast<ID3D11Device*>(d3d_dev), static_cast<ID3D11DeviceContext*>(d3d_ctx)) }
    {
    }
    TextureID Renderer::LoadTexture(const std::filesystem::path& path, bool linear)
    {
        return std::static_pointer_cast<RendererImpl>(m_impl)->LoadTexture(path, linear);
    }
    void Renderer::Render(int w, int h, void* rtv, const Scene& scene)
    {
        std::static_pointer_cast<RendererImpl>(m_impl)->Render(w, h, static_cast<ID3D11RenderTargetView*>(rtv), scene);
    }
}
