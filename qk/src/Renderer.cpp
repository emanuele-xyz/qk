#include <qk/PCH.h>
#include <qk/Renderer.h>
#include <qk/Mesh.h>
#include <qk/Texture.h>
#include <qk/D11.h>

#include <SimpleMath.h>
using Matrix = DirectX::SimpleMath::Matrix;
using Vector3 = DirectX::SimpleMath::Vector3;
namespace dx = DirectX; // for DirectX namespace included by DirectXMath (included by SimpleMath)

#define int std::int32_t
#define matrix Matrix
#define float3 Vector3
#include <qk/hlsl/OpaquePassBuffers.h>
#include <qk/hlsl/GizmoPassBuffers.h>
#undef float3
#undef matrix
#undef int

namespace qk
{
    constexpr DXGI_FORMAT MESH_INDEX_FORMAT{ DXGI_FORMAT_R32_UINT };
    static_assert(sizeof(MeshIndex) == 4);

    class Mesh
    {
    public:
        static Mesh Cube(ID3D11Device* dev);
        static Mesh Quad(ID3D11Device* dev);
        static Mesh Icosphere(ID3D11Device* dev);
        static Mesh Cone(ID3D11Device* dev);
        static Mesh ConeNoBase(ID3D11Device* dev);
    public:
        Mesh(ID3D11Device* dev, std::span<const MeshVertex> vertices, std::span<const MeshIndex> indices);
        ~Mesh() = default;
        Mesh(const Mesh&) = delete;
        Mesh(Mesh&&) noexcept = default;
        Mesh& operator=(const Mesh&) = delete;
        Mesh& operator=(Mesh&&) noexcept = default;
    public:
        ID3D11Buffer* Vertices() const noexcept { return m_vertices.Get(); }
        ID3D11Buffer* Indices() const noexcept { return m_indices.Get(); }
        UINT VertexCount() const noexcept { return m_vertex_count; }
        UINT IndexCount() const noexcept { return m_index_count; }
    private:
        wrl::ComPtr<ID3D11Buffer> m_vertices;
        wrl::ComPtr<ID3D11Buffer> m_indices;
        UINT m_vertex_count;
        UINT m_index_count;
    };
    Mesh Mesh::Cube(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
            // front face (Z+)
            { { -0.5f, -0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, +0.5f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f } },

            // back face (Z-)
            { { +0.5f, -0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 0.0f, 1.0f } },
            { { -0.5f, -0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 1.0f, 1.0f } },
            { { -0.5f, +0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 1.0f, 0.0f } },
            { { +0.5f, +0.5f, -0.5f }, { 0.0f, 0.0f, -1.0f }, { 0.0f, 0.0f } },

            // left face (X-)
            { { -0.5f, -0.5f, -0.5f }, { -1.0f, 0.0f, 0.0f }, { 0.0f, 1.0f } },
            { { -0.5f, -0.5f, +0.5f }, { -1.0f, 0.0f, 0.0f }, { 1.0f, 1.0f } },
            { { -0.5f, +0.5f, +0.5f }, { -1.0f, 0.0f, 0.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, -0.5f }, { -1.0f, 0.0f, 0.0f }, { 0.0f, 0.0f } },

            // right face (X+)
            { { +0.5f, -0.5f, +0.5f }, { +1.0f, 0.0f, 0.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, -0.5f }, { +1.0f, 0.0f, 0.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, -0.5f }, { +1.0f, 0.0f, 0.0f }, { 1.0f, 0.0f } },
            { { +0.5f, +0.5f, +0.5f }, { +1.0f, 0.0f, 0.0f }, { 0.0f, 0.0f } },

            // top face (Y+)
            { { -0.5f, +0.5f, +0.5f }, { 0.0f, +1.0f, 0.0f }, { 0.0f, 1.0f } },
            { { +0.5f, +0.5f, +0.5f }, { 0.0f, +1.0f, 0.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, -0.5f }, { 0.0f, +1.0f, 0.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, -0.5f }, { 0.0f, +1.0f, 0.0f }, { 0.0f, 0.0f } },

            // bottom face (Y-)
            { { -0.5f, -0.5f, -0.5f }, { 0.0f, -1.0f, 0.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, -0.5f }, { 0.0f, -1.0f, 0.0f }, { 1.0f, 1.0f } },
            { { +0.5f, -0.5f, +0.5f }, { 0.0f, -1.0f, 0.0f }, { 1.0f, 0.0f } },
            { { -0.5f, -0.5f, +0.5f }, { 0.0f, -1.0f, 0.0f }, { 0.0f, 0.0f } },
        };

        MeshIndex indices[]
        {
            // front
            0, 1, 2,
            0, 2, 3,

            // back
            4, 5, 6,
            4, 6, 7,

            // left
            8, 9,10,
            8,10,11,

            // right
            12,13,14,
            12,14,15,

            // top 
            16,17,18,
            16,18,19,

            // bottom
            20,21,22,
            20,22,23
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::Quad(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
            { { -0.5f, -0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 1.0f } },
            { { +0.5f, -0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 1.0f } },
            { { +0.5f, +0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 1.0f, 0.0f } },
            { { -0.5f, +0.5f, +0.0f }, { 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f } },
        };

        MeshIndex indices[]
        {
            0, 1, 2,
            0, 2, 3,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::Icosphere(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.181819f , 0.000000f } },
        { { 0.101590f, -0.483975f, 0.073809f }, { 0.211000f, -0.965400f, 0.153300f }, { 0.204546f , 0.039365f } },
        { { -0.038803f, -0.483975f, 0.119426f }, { -0.080600f, -0.965400f, 0.248000f }, { 0.159092f , 0.039365f } },
        { { 0.361804f, -0.223610f, 0.262863f }, { 0.723600f, -0.447200f, 0.525700f }, { 0.272728f , 0.157461f } },
        { { 0.304773f, -0.328759f, 0.221428f }, { 0.604200f, -0.665000f, 0.439000f }, { 0.295455f , 0.118096f } },
        { { 0.406365f, -0.251150f, 0.147619f }, { 0.815200f, -0.503800f, 0.285700f }, { 0.318182f , 0.157461f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.909091f , 0.000000f } },
        { { -0.038803f, -0.483975f, 0.119426f }, { -0.080600f, -0.965400f, 0.248000f }, { 0.931818f , 0.039365f } },
        { { -0.125573f, -0.483974f, 0.000000f }, { -0.260800f, -0.965400f, -0.000000f }, { 0.886364f , 0.039365f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.727273f , 0.000000f } },
        { { -0.125573f, -0.483974f, 0.000000f }, { -0.260800f, -0.965400f, -0.000000f }, { 0.750000f , 0.039365f } },
        { { -0.038803f, -0.483975f, -0.119426f }, { -0.080600f, -0.965400f, -0.248000f }, { 0.704546f , 0.039365f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.545455f , 0.000000f } },
        { { -0.038803f, -0.483975f, -0.119426f }, { -0.080600f, -0.965400f, -0.248000f }, { 0.568182f , 0.039365f } },
        { { 0.101590f, -0.483975f, -0.073809f }, { 0.211000f, -0.965400f, -0.153300f }, { 0.522728f , 0.039365f } },
        { { 0.430349f, -0.125575f, 0.221429f }, { 0.865000f, -0.243100f, 0.439000f }, { 0.295455f , 0.196826f } },
        { { -0.138194f, -0.223610f, 0.425325f }, { -0.276400f, -0.447200f, 0.850600f }, { 0.090910f , 0.157461f } },
        { { -0.014820f, -0.251151f, 0.432092f }, { -0.019800f, -0.503800f, 0.863600f }, { 0.136364f , 0.157461f } },
        { { -0.077608f, -0.125576f, 0.477711f }, { -0.150200f, -0.243100f, 0.958300f }, { 0.113637f , 0.196826f } },
        { { -0.447213f, -0.223608f, 0.000000f }, { -0.894400f, -0.447200f, -0.000000f }, { 0.818182f , 0.157461f } },
        { { -0.415525f, -0.251149f, 0.119427f }, { -0.827400f, -0.503800f, 0.248000f }, { 0.863636f , 0.157461f } },
        { { -0.478313f, -0.125575f, 0.073809f }, { -0.957800f, -0.243100f, 0.153300f }, { 0.840909f , 0.196826f } },
        { { -0.138194f, -0.223610f, -0.425325f }, { -0.276400f, -0.447200f, -0.850600f }, { 0.636364f , 0.157461f } },
        { { -0.241986f, -0.251151f, -0.358282f }, { -0.491500f, -0.503800f, -0.710300f }, { 0.681818f , 0.157461f } },
        { { -0.218003f, -0.125576f, -0.432094f }, { -0.441700f, -0.243100f, -0.863600f }, { 0.659091f , 0.196826f } },
        { { 0.361804f, -0.223610f, -0.262863f }, { 0.723600f, -0.447200f, -0.525700f }, { 0.454546f , 0.157461f } },
        { { 0.265970f, -0.251151f, -0.340856f }, { 0.523700f, -0.503800f, -0.687000f }, { 0.500000f , 0.157461f } },
        { { 0.343579f, -0.125576f, -0.340858f }, { 0.684800f, -0.243100f, -0.687000f }, { 0.477273f , 0.196826f } },
        { { 0.343579f, -0.125576f, 0.340858f }, { 0.684800f, -0.243100f, 0.687000f }, { 0.250001f , 0.196826f } },
        { { -0.218003f, -0.125576f, 0.432094f }, { -0.441700f, -0.243100f, 0.863600f }, { 0.068182f , 0.196826f } },
        { { -0.478313f, -0.125575f, -0.073809f }, { -0.957800f, -0.243100f, -0.153300f }, { 0.795455f , 0.196826f } },
        { { -0.077608f, -0.125576f, -0.477711f }, { -0.150200f, -0.243100f, -0.958300f }, { 0.613637f , 0.196826f } },
        { { 0.430349f, -0.125575f, -0.221429f }, { 0.865000f, -0.243100f, -0.439000f }, { 0.431819f , 0.196826f } },
        { { 0.138194f, 0.223610f, 0.425325f }, { 0.276400f, 0.447200f, 0.850600f }, { 0.181819f , 0.314921f } },
        { { 0.241986f, 0.251151f, 0.358282f }, { 0.491500f, 0.503800f, 0.710300f }, { 0.227273f , 0.314921f } },
        { { 0.116411f, 0.328760f, 0.358282f }, { 0.230800f, 0.665000f, 0.710300f }, { 0.204546f , 0.354286f } },
        { { -0.361804f, 0.223610f, 0.262863f }, { -0.723600f, 0.447200f, 0.525700f }, { 0.000000f , 0.314921f } },
        { { -0.265970f, 0.251151f, 0.340856f }, { -0.523700f, 0.503800f, 0.687000f }, { 0.045455f , 0.314921f } },
        { { -0.304773f, 0.328759f, 0.221428f }, { -0.604200f, 0.665000f, 0.439000f }, { 0.022727f , 0.354286f } },
        { { -0.361804f, 0.223610f, -0.262863f }, { -0.723600f, 0.447200f, -0.525700f }, { 0.727273f , 0.314921f } },
        { { -0.406365f, 0.251150f, -0.147619f }, { -0.815200f, 0.503800f, -0.285700f }, { 0.772727f , 0.314921f } },
        { { -0.304773f, 0.328759f, -0.221428f }, { -0.604200f, 0.665000f, -0.439000f }, { 0.750000f , 0.354286f } },
        { { 0.138194f, 0.223610f, -0.425325f }, { 0.276400f, 0.447200f, -0.850600f }, { 0.545455f , 0.314921f } },
        { { 0.014820f, 0.251151f, -0.432092f }, { 0.019800f, 0.503800f, -0.863600f }, { 0.590909f , 0.314921f } },
        { { 0.116411f, 0.328760f, -0.358282f }, { 0.230800f, 0.665000f, -0.710300f }, { 0.568182f , 0.354286f } },
        { { 0.447213f, 0.223608f, 0.000000f }, { 0.894400f, 0.447200f, -0.000000f }, { 0.363637f , 0.314921f } },
        { { 0.415525f, 0.251149f, -0.119427f }, { 0.827400f, 0.503800f, -0.248000f }, { 0.409091f , 0.314921f } },
        { { 0.376721f, 0.328757f, 0.000000f }, { 0.746900f, 0.665000f, -0.000000f }, { 0.386364f , 0.354286f } },
        { { 0.125573f, 0.483974f, 0.000000f }, { 0.260700f, 0.965400f, -0.000000f }, { 0.431819f , 0.433017f } },
        { { 0.038803f, 0.483975f, -0.119426f }, { 0.080600f, 0.965400f, -0.248000f }, { 0.477273f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.454546f , 0.472382f } },
        { { 0.262865f, 0.425326f, 0.000000f }, { 0.525700f, 0.850700f, -0.000000f }, { 0.409091f , 0.393651f } },
        { { 0.180900f, 0.447215f, -0.131431f }, { 0.368200f, 0.890400f, -0.267500f }, { 0.454546f , 0.393651f } },
        { { 0.319097f, 0.361805f, -0.131432f }, { 0.631700f, 0.727500f, -0.267500f }, { 0.431819f , 0.354286f } },
        { { 0.081228f, 0.425327f, -0.249998f }, { 0.162500f, 0.850700f, -0.500000f }, { 0.500000f , 0.393651f } },
        { { 0.223605f, 0.361806f, -0.262864f }, { 0.449600f, 0.727600f, -0.518200f }, { 0.477273f , 0.354286f } },
        { { 0.116411f, 0.328760f, -0.358282f }, { 0.230800f, 0.665000f, -0.710300f }, { 0.522728f , 0.354286f } },
        { { 0.344095f, 0.262868f, -0.249998f }, { 0.688200f, 0.525700f, -0.500000f }, { 0.454546f , 0.314921f } },
        { { 0.241986f, 0.251151f, -0.358282f }, { 0.491500f, 0.503800f, -0.710300f }, { 0.500000f , 0.314921f } },
        { { 0.038803f, 0.483975f, -0.119426f }, { 0.080600f, 0.965400f, -0.248000f }, { 0.613637f , 0.433017f } },
        { { -0.101590f, 0.483975f, -0.073809f }, { -0.211000f, 0.965400f, -0.153300f }, { 0.659091f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.636364f , 0.472382f } },
        { { 0.081228f, 0.425327f, -0.249998f }, { 0.162500f, 0.850700f, -0.500000f }, { 0.590909f , 0.393651f } },
        { { -0.069099f, 0.447215f, -0.212660f }, { -0.140600f, 0.890400f, -0.432900f }, { 0.636364f , 0.393651f } },
        { { -0.026395f, 0.361806f, -0.344092f }, { -0.059200f, 0.727600f, -0.683500f }, { 0.613637f , 0.354286f } },
        { { -0.212661f, 0.425327f, -0.154506f }, { -0.425300f, 0.850700f, -0.309000f }, { 0.681818f , 0.393651f } },
        { { -0.180902f, 0.361806f, -0.293889f }, { -0.353900f, 0.727600f, -0.587800f }, { 0.659091f , 0.354286f } },
        { { -0.304773f, 0.328759f, -0.221428f }, { -0.604200f, 0.665000f, -0.439000f }, { 0.704546f , 0.354286f } },
        { { -0.131434f, 0.262869f, -0.404506f }, { -0.262900f, 0.525700f, -0.809000f }, { 0.636364f , 0.314921f } },
        { { -0.265970f, 0.251151f, -0.340856f }, { -0.523700f, 0.503800f, -0.687000f }, { 0.681818f , 0.314921f } },
        { { -0.101590f, 0.483975f, -0.073809f }, { -0.211000f, 0.965400f, -0.153300f }, { 0.795455f , 0.433017f } },
        { { -0.101590f, 0.483975f, 0.073809f }, { -0.211000f, 0.965400f, 0.153300f }, { 0.840909f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.818182f , 0.472382f } },
        { { -0.212661f, 0.425327f, -0.154506f }, { -0.425300f, 0.850700f, -0.309000f }, { 0.772727f , 0.393651f } },
        { { -0.223605f, 0.447215f, 0.000000f }, { -0.455100f, 0.890400f, -0.000000f }, { 0.818182f , 0.393651f } },
        { { -0.335408f, 0.361805f, -0.081229f }, { -0.668300f, 0.727600f, -0.154900f }, { 0.795455f , 0.354286f } },
        { { -0.212661f, 0.425327f, 0.154506f }, { -0.425300f, 0.850700f, 0.309000f }, { 0.863636f , 0.393651f } },
        { { -0.335408f, 0.361805f, 0.081229f }, { -0.668300f, 0.727600f, 0.154900f }, { 0.840909f , 0.354286f } },
        { { -0.304773f, 0.328759f, 0.221428f }, { -0.604200f, 0.665000f, 0.439000f }, { 0.886364f , 0.354286f } },
        { { -0.425324f, 0.262868f, 0.000000f }, { -0.850600f, 0.525700f, -0.000000f }, { 0.818182f , 0.314921f } },
        { { -0.406365f, 0.251150f, 0.147619f }, { -0.815200f, 0.503800f, 0.285700f }, { 0.863636f , 0.314921f } },
        { { -0.361804f, 0.223610f, 0.262863f }, { -0.723600f, 0.447200f, 0.525700f }, { 0.909091f , 0.314921f } },
        { { -0.101590f, 0.483975f, 0.073809f }, { -0.211000f, 0.965400f, 0.153300f }, { 0.068182f , 0.433017f } },
        { { 0.038803f, 0.483975f, 0.119426f }, { 0.080600f, 0.965400f, 0.248000f }, { 0.113637f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.090910f , 0.472382f } },
        { { -0.212661f, 0.425327f, 0.154506f }, { -0.425300f, 0.850700f, 0.309000f }, { 0.045455f , 0.393651f } },
        { { -0.069099f, 0.447215f, 0.212660f }, { -0.140600f, 0.890400f, 0.432900f }, { 0.090910f , 0.393651f } },
        { { -0.180902f, 0.361806f, 0.293889f }, { -0.353900f, 0.727600f, 0.587800f }, { 0.068182f , 0.354286f } },
        { { 0.081228f, 0.425327f, 0.249998f }, { 0.162500f, 0.850700f, 0.500000f }, { 0.136365f , 0.393651f } },
        { { -0.026395f, 0.361806f, 0.344092f }, { -0.059200f, 0.727600f, 0.683500f }, { 0.113637f , 0.354286f } },
        { { 0.116411f, 0.328760f, 0.358282f }, { 0.230800f, 0.665000f, 0.710300f }, { 0.159092f , 0.354286f } },
        { { -0.131434f, 0.262869f, 0.404506f }, { -0.262900f, 0.525700f, 0.809000f }, { 0.090909f , 0.314921f } },
        { { 0.014820f, 0.251151f, 0.432092f }, { 0.019800f, 0.503800f, 0.863600f }, { 0.136364f , 0.314921f } },
        { { 0.038803f, 0.483975f, 0.119426f }, { 0.080600f, 0.965400f, 0.248000f }, { 0.250001f , 0.433017f } },
        { { 0.125573f, 0.483974f, 0.000000f }, { 0.260700f, 0.965400f, -0.000000f }, { 0.295455f , 0.433017f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.272728f , 0.472382f } },
        { { 0.081228f, 0.425327f, 0.249998f }, { 0.162500f, 0.850700f, 0.500000f }, { 0.227273f , 0.393651f } },
        { { 0.180900f, 0.447215f, 0.131431f }, { 0.368200f, 0.890400f, 0.267500f }, { 0.272728f , 0.393651f } },
        { { 0.223605f, 0.361806f, 0.262864f }, { 0.449600f, 0.727600f, 0.518200f }, { 0.250001f , 0.354286f } },
        { { 0.262865f, 0.425326f, 0.000000f }, { 0.525700f, 0.850700f, -0.000000f }, { 0.318182f , 0.393651f } },
        { { 0.319097f, 0.361805f, 0.131432f }, { 0.631700f, 0.727500f, 0.267500f }, { 0.295455f , 0.354286f } },
        { { 0.376721f, 0.328757f, 0.000000f }, { 0.746900f, 0.665000f, -0.000000f }, { 0.340910f , 0.354286f } },
        { { 0.344095f, 0.262868f, 0.249998f }, { 0.688200f, 0.525700f, 0.500000f }, { 0.272728f , 0.314921f } },
        { { 0.415525f, 0.251149f, 0.119427f }, { 0.827400f, 0.503800f, 0.248000f }, { 0.318182f , 0.314921f } },
        { { 0.478313f, 0.125575f, -0.073809f }, { 0.957800f, 0.243100f, -0.153300f }, { 0.386364f , 0.275556f } },
        { { 0.475529f, 0.000000f, -0.154506f }, { 0.951100f, -0.000000f, -0.309000f }, { 0.409091f , 0.236191f } },
        { { 0.430902f, 0.138198f, -0.212661f }, { 0.859300f, 0.272400f, -0.432900f }, { 0.431819f , 0.275556f } },
        { { 0.404510f, 0.000000f, -0.293891f }, { 0.809000f, 0.008900f, -0.587800f }, { 0.454546f , 0.236191f } },
        { { 0.335410f, 0.138199f, -0.344095f }, { 0.677200f, 0.272400f, -0.683500f }, { 0.477273f , 0.275556f } },
        { { 0.293893f, -0.000000f, -0.404508f }, { 0.587800f, -0.000000f, -0.809000f }, { 0.500000f , 0.236191f } },
        { { 0.218003f, 0.125576f, -0.432094f }, { 0.441700f, 0.243100f, -0.863600f }, { 0.522728f , 0.275556f } },
        { { 0.077608f, 0.125576f, -0.477711f }, { 0.150200f, 0.243100f, -0.958300f }, { 0.568182f , 0.275556f } },
        { { 0.000000f, 0.000000f, -0.500000f }, { -0.000000f, -0.000000f, -1.000000f }, { 0.590909f , 0.236191f } },
        { { -0.069099f, 0.138199f, -0.475528f }, { -0.146100f, 0.272400f, -0.951000f }, { 0.613637f , 0.275556f } },
        { { -0.154508f, -0.000000f, -0.475528f }, { -0.309000f, 0.008900f, -0.951000f }, { 0.636364f , 0.236191f } },
        { { -0.223608f, 0.138199f, -0.425324f }, { -0.440800f, 0.272400f, -0.855300f }, { 0.659091f , 0.275556f } },
        { { -0.293893f, -0.000000f, -0.404508f }, { -0.587800f, -0.000000f, -0.809000f }, { 0.681818f , 0.236191f } },
        { { -0.343579f, 0.125576f, -0.340858f }, { -0.684800f, 0.243100f, -0.687000f }, { 0.704546f , 0.275556f } },
        { { -0.430349f, 0.125575f, -0.221429f }, { -0.865000f, 0.243100f, -0.439000f }, { 0.750000f , 0.275556f } },
        { { -0.475529f, 0.000000f, -0.154506f }, { -0.951100f, -0.000000f, -0.309000f }, { 0.772727f , 0.236191f } },
        { { -0.473607f, 0.138198f, -0.081229f }, { -0.949600f, 0.272400f, -0.154900f }, { 0.795455f , 0.275556f } },
        { { -0.500000f, 0.000000f, 0.000000f }, { -1.000000f, 0.008900f, -0.000000f }, { 0.818182f , 0.236191f } },
        { { -0.473606f, 0.138198f, 0.081229f }, { -0.949600f, 0.272400f, 0.154900f }, { 0.840909f , 0.275556f } },
        { { -0.475529f, -0.000000f, 0.154506f }, { -0.951100f, -0.000000f, 0.309000f }, { 0.863636f , 0.236191f } },
        { { -0.430349f, 0.125575f, 0.221429f }, { -0.865000f, 0.243100f, 0.439000f }, { 0.886364f , 0.275556f } },
        { { -0.343579f, 0.125576f, 0.340858f }, { -0.684800f, 0.243100f, 0.687000f }, { 0.022727f , 0.275556f } },
        { { -0.293893f, 0.000000f, 0.404508f }, { -0.587800f, -0.000000f, 0.809000f }, { 0.045455f , 0.236191f } },
        { { -0.223608f, 0.138198f, 0.425324f }, { -0.440800f, 0.272400f, 0.855300f }, { 0.068182f , 0.275556f } },
        { { -0.154509f, -0.000000f, 0.475528f }, { -0.309000f, 0.008900f, 0.951000f }, { 0.090910f , 0.236191f } },
        { { -0.069100f, 0.138198f, 0.475528f }, { -0.146100f, 0.272400f, 0.951000f }, { 0.113637f , 0.275556f } },
        { { 0.000000f, -0.000000f, 0.500000f }, { -0.000000f, -0.000000f, 1.000000f }, { 0.136364f , 0.236191f } },
        { { 0.077608f, 0.125576f, 0.477711f }, { 0.150200f, 0.243100f, 0.958300f }, { 0.159092f , 0.275556f } },
        { { 0.218003f, 0.125576f, 0.432094f }, { 0.441700f, 0.243100f, 0.863600f }, { 0.204546f , 0.275556f } },
        { { 0.293893f, 0.000000f, 0.404508f }, { 0.587800f, -0.000000f, 0.809000f }, { 0.227273f , 0.236191f } },
        { { 0.335410f, 0.138198f, 0.344095f }, { 0.677200f, 0.272400f, 0.683500f }, { 0.250001f , 0.275556f } },
        { { 0.404509f, -0.000001f, 0.293891f }, { 0.809000f, 0.008900f, 0.587800f }, { 0.272728f , 0.236191f } },
        { { 0.430902f, 0.138197f, 0.212662f }, { 0.859300f, 0.272400f, 0.432900f }, { 0.295455f , 0.275556f } },
        { { 0.475529f, -0.000000f, 0.154506f }, { 0.951100f, -0.000000f, 0.309000f }, { 0.318182f , 0.236191f } },
        { { 0.478313f, 0.125575f, 0.073809f }, { 0.957800f, 0.243100f, 0.153300f }, { 0.340910f , 0.275556f } },
        { { 0.154509f, -0.000000f, -0.475528f }, { 0.309000f, -0.008900f, -0.951000f }, { 0.545455f , 0.236191f } },
        { { 0.223608f, -0.138199f, -0.425324f }, { 0.440800f, -0.272400f, -0.855300f }, { 0.522728f , 0.196826f } },
        { { 0.069100f, -0.138199f, -0.475527f }, { 0.146100f, -0.272400f, -0.951000f }, { 0.568182f , 0.196826f } },
        { { 0.131434f, -0.262869f, -0.404506f }, { 0.262900f, -0.525700f, -0.809000f }, { 0.545455f , 0.157461f } },
        { { -0.014820f, -0.251151f, -0.432092f }, { -0.019800f, -0.503800f, -0.863600f }, { 0.590909f , 0.157461f } },
        { { -0.404509f, -0.000000f, -0.293892f }, { -0.809000f, -0.008900f, -0.587800f }, { 0.727273f , 0.236191f } },
        { { -0.335409f, -0.138199f, -0.344095f }, { -0.677200f, -0.272400f, -0.683500f }, { 0.704546f , 0.196826f } },
        { { -0.430902f, -0.138198f, -0.212662f }, { -0.859300f, -0.272400f, -0.432900f }, { 0.750000f , 0.196826f } },
        { { -0.344095f, -0.262868f, -0.249998f }, { -0.688200f, -0.525700f, -0.500000f }, { 0.727273f , 0.157461f } },
        { { -0.415525f, -0.251149f, -0.119427f }, { -0.827400f, -0.503800f, -0.248000f }, { 0.772727f , 0.157461f } },
        { { -0.343579f, 0.125576f, 0.340858f }, { -0.684800f, 0.243100f, 0.687000f }, { 0.931818f , 0.275556f } },
        { { -0.404509f, 0.000000f, 0.293892f }, { -0.809000f, -0.008900f, 0.587800f }, { 0.909091f , 0.236191f } },
        { { -0.430902f, -0.138198f, 0.212662f }, { -0.859300f, -0.272400f, 0.432900f }, { 0.886364f , 0.196826f } },
        { { -0.293893f, 0.000000f, 0.404508f }, { -0.587800f, -0.000000f, 0.809000f }, { 0.954545f , 0.236191f } },
        { { -0.335410f, -0.138199f, 0.344095f }, { -0.677200f, -0.272400f, 0.683500f }, { 0.931818f , 0.196826f } },
        { { -0.218003f, -0.125576f, 0.432094f }, { -0.441700f, -0.243100f, 0.863600f }, { 0.977273f , 0.196826f } },
        { { -0.344095f, -0.262868f, 0.249998f }, { -0.688200f, -0.525700f, 0.500000f }, { 0.909091f , 0.157461f } },
        { { -0.241986f, -0.251151f, 0.358282f }, { -0.491500f, -0.503800f, 0.710300f }, { 0.954545f , 0.157461f } },
        { { -0.138194f, -0.223610f, 0.425325f }, { -0.276400f, -0.447200f, 0.850600f }, { 1.000000f , 0.157461f } },
        { { 0.154509f, 0.000000f, 0.475528f }, { 0.309000f, -0.008900f, 0.951000f }, { 0.181819f , 0.236191f } },
        { { 0.069100f, -0.138199f, 0.475527f }, { 0.146100f, -0.272400f, 0.951000f }, { 0.159092f , 0.196826f } },
        { { 0.223608f, -0.138199f, 0.425324f }, { 0.440800f, -0.272400f, 0.855300f }, { 0.204546f , 0.196826f } },
        { { 0.131434f, -0.262869f, 0.404506f }, { 0.262900f, -0.525700f, 0.809000f }, { 0.181819f , 0.157461f } },
        { { 0.265970f, -0.251151f, 0.340856f }, { 0.523700f, -0.503800f, 0.687000f }, { 0.227274f , 0.157461f } },
        { { 0.500000f, 0.000000f, 0.000000f }, { 1.000000f, -0.008900f, -0.000000f }, { 0.363637f , 0.236191f } },
        { { 0.473607f, -0.138198f, 0.081229f }, { 0.949600f, -0.272400f, 0.154900f }, { 0.340910f , 0.196826f } },
        { { 0.473607f, -0.138198f, -0.081229f }, { 0.949600f, -0.272400f, -0.154900f }, { 0.386364f , 0.196826f } },
        { { 0.425324f, -0.262868f, 0.000000f }, { 0.850600f, -0.525700f, -0.000000f }, { 0.363637f , 0.157461f } },
        { { 0.406365f, -0.251150f, -0.147619f }, { 0.815200f, -0.503800f, -0.285700f }, { 0.409092f , 0.157461f } },
        { { 0.304773f, -0.328759f, -0.221428f }, { 0.604200f, -0.665000f, -0.439000f }, { 0.477273f , 0.118096f } },
        { { 0.212661f, -0.425327f, -0.154506f }, { 0.425300f, -0.850700f, -0.309000f }, { 0.500000f , 0.078731f } },
        { { 0.180902f, -0.361806f, -0.293890f }, { 0.353900f, -0.727600f, -0.587800f }, { 0.522728f , 0.118096f } },
        { { 0.069098f, -0.447215f, -0.212661f }, { 0.140600f, -0.890400f, -0.432900f }, { 0.545455f , 0.078731f } },
        { { 0.026395f, -0.361805f, -0.344093f }, { 0.059200f, -0.727600f, -0.683500f }, { 0.568182f , 0.118096f } },
        { { -0.081228f, -0.425327f, -0.249998f }, { -0.162500f, -0.850700f, -0.500000f }, { 0.590909f , 0.078731f } },
        { { -0.116411f, -0.328760f, -0.358282f }, { -0.230800f, -0.665000f, -0.710300f }, { 0.613637f , 0.118096f } },
        { { -0.116411f, -0.328760f, -0.358282f }, { -0.230800f, -0.665000f, -0.710300f }, { 0.659091f , 0.118096f } },
        { { -0.081228f, -0.425327f, -0.249998f }, { -0.162500f, -0.850700f, -0.500000f }, { 0.681818f , 0.078731f } },
        { { -0.223605f, -0.361806f, -0.262864f }, { -0.449600f, -0.727600f, -0.518200f }, { 0.704546f , 0.118096f } },
        { { -0.180901f, -0.447214f, -0.131431f }, { -0.368200f, -0.890400f, -0.267500f }, { 0.727273f , 0.078731f } },
        { { -0.319097f, -0.361805f, -0.131431f }, { -0.631700f, -0.727500f, -0.267500f }, { 0.750000f , 0.118096f } },
        { { -0.262865f, -0.425326f, 0.000000f }, { -0.525700f, -0.850700f, -0.000000f }, { 0.772727f , 0.078731f } },
        { { -0.376721f, -0.328757f, 0.000000f }, { -0.746900f, -0.665000f, -0.000000f }, { 0.795455f , 0.118096f } },
        { { -0.376721f, -0.328757f, 0.000000f }, { -0.746900f, -0.665000f, -0.000000f }, { 0.840909f , 0.118096f } },
        { { -0.262865f, -0.425326f, 0.000000f }, { -0.525700f, -0.850700f, -0.000000f }, { 0.863636f , 0.078731f } },
        { { -0.319097f, -0.361805f, 0.131432f }, { -0.631700f, -0.727500f, 0.267500f }, { 0.886364f , 0.118096f } },
        { { -0.180901f, -0.447214f, 0.131432f }, { -0.368200f, -0.890400f, 0.267500f }, { 0.909091f , 0.078731f } },
        { { -0.223605f, -0.361805f, 0.262864f }, { -0.449600f, -0.727500f, 0.518200f }, { 0.931818f , 0.118096f } },
        { { -0.081228f, -0.425327f, 0.249998f }, { -0.162500f, -0.850700f, 0.500000f }, { 0.954545f , 0.078731f } },
        { { -0.116411f, -0.328760f, 0.358282f }, { -0.230800f, -0.665000f, 0.710300f }, { 0.977273f , 0.118096f } },
        { { 0.304773f, -0.328759f, -0.221428f }, { 0.604200f, -0.665000f, -0.439000f }, { 0.431819f , 0.118096f } },
        { { 0.335409f, -0.361805f, -0.081228f }, { 0.668300f, -0.727500f, -0.154900f }, { 0.386364f , 0.118096f } },
        { { 0.335409f, -0.361805f, 0.081229f }, { 0.668300f, -0.727500f, 0.154900f }, { 0.340910f , 0.118096f } },
        { { 0.212661f, -0.425327f, -0.154506f }, { 0.425300f, -0.850700f, -0.309000f }, { 0.409091f , 0.078731f } },
        { { 0.223605f, -0.447214f, 0.000000f }, { 0.455100f, -0.890400f, -0.000000f }, { 0.363637f , 0.078730f } },
        { { 0.101590f, -0.483975f, -0.073809f }, { 0.211000f, -0.965400f, -0.153300f }, { 0.386364f , 0.039365f } },
        { { 0.212661f, -0.425327f, 0.154506f }, { 0.425300f, -0.850700f, 0.309000f }, { 0.318182f , 0.078731f } },
        { { 0.101590f, -0.483975f, 0.073809f }, { 0.211000f, -0.965400f, 0.153300f }, { 0.340910f , 0.039365f } },
        { { 0.000000f, -0.500000f, 0.000000f }, { -0.000000f, -1.000000f, -0.000000f }, { 0.363637f , 0.000000f } },
        { { -0.116411f, -0.328760f, 0.358282f }, { -0.230800f, -0.665000f, 0.710300f }, { 0.113637f , 0.118096f } },
        { { -0.081228f, -0.425327f, 0.249998f }, { -0.162500f, -0.850700f, 0.500000f }, { 0.136365f , 0.078731f } },
        { { 0.026395f, -0.361806f, 0.344093f }, { 0.059200f, -0.727600f, 0.683500f }, { 0.159092f , 0.118096f } },
        { { 0.069099f, -0.447215f, 0.212660f }, { 0.140600f, -0.890400f, 0.432900f }, { 0.181819f , 0.078731f } },
        { { 0.180902f, -0.361805f, 0.293890f }, { 0.353900f, -0.727600f, 0.587800f }, { 0.204546f , 0.118096f } },
        { { 0.212661f, -0.425327f, 0.154506f }, { 0.425300f, -0.850700f, 0.309000f }, { 0.227273f , 0.078731f } },
        { { 0.304773f, -0.328759f, 0.221428f }, { 0.604200f, -0.665000f, 0.439000f }, { 0.250001f , 0.118096f } },
        };
        MeshIndex indices[]
        {
        0, 1, 2,
        3, 4, 5,
        6, 7, 8,
        9, 10, 11,
        12, 13, 14,
        3, 5, 15,
        16, 17, 18,
        19, 20, 21,
        22, 23, 24,
        25, 26, 27,
        3, 15, 28,
        16, 18, 29,
        19, 21, 30,
        22, 24, 31,
        25, 27, 32,
        33, 34, 35,
        36, 37, 38,
        39, 40, 41,
        42, 43, 44,
        45, 46, 47,
        48, 49, 50,
        51, 52, 48,
        47, 53, 51,
        48, 52, 49,
        52, 54, 49,
        51, 53, 52,
        53, 55, 52,
        52, 55, 54,
        55, 56, 54,
        47, 46, 53,
        46, 57, 53,
        53, 57, 55,
        57, 58, 55,
        55, 58, 56,
        58, 42, 56,
        59, 60, 61,
        62, 63, 59,
        44, 64, 62,
        59, 63, 60,
        63, 65, 60,
        62, 64, 63,
        64, 66, 63,
        63, 66, 65,
        66, 67, 65,
        44, 43, 64,
        43, 68, 64,
        64, 68, 66,
        68, 69, 66,
        66, 69, 67,
        69, 39, 67,
        70, 71, 72,
        73, 74, 70,
        41, 75, 73,
        70, 74, 71,
        74, 76, 71,
        73, 75, 74,
        75, 77, 74,
        74, 77, 76,
        77, 78, 76,
        41, 40, 75,
        40, 79, 75,
        75, 79, 77,
        79, 80, 77,
        77, 80, 78,
        80, 81, 78,
        82, 83, 84,
        85, 86, 82,
        38, 87, 85,
        82, 86, 83,
        86, 88, 83,
        85, 87, 86,
        87, 89, 86,
        86, 89, 88,
        89, 90, 88,
        38, 37, 87,
        37, 91, 87,
        87, 91, 89,
        91, 92, 89,
        89, 92, 90,
        92, 33, 90,
        93, 94, 95,
        96, 97, 93,
        35, 98, 96,
        93, 97, 94,
        97, 99, 94,
        96, 98, 97,
        98, 100, 97,
        97, 100, 99,
        100, 101, 99,
        35, 34, 98,
        34, 102, 98,
        98, 102, 100,
        102, 103, 100,
        100, 103, 101,
        103, 45, 101,
        104, 46, 45,
        105, 106, 104,
        32, 107, 105,
        104, 106, 46,
        106, 57, 46,
        105, 107, 106,
        107, 108, 106,
        106, 108, 57,
        108, 58, 57,
        32, 27, 107,
        27, 109, 107,
        107, 109, 108,
        109, 110, 108,
        108, 110, 58,
        110, 42, 58,
        111, 43, 42,
        112, 113, 111,
        31, 114, 112,
        111, 113, 43,
        113, 68, 43,
        112, 114, 113,
        114, 115, 113,
        113, 115, 68,
        115, 69, 68,
        31, 24, 114,
        24, 116, 114,
        114, 116, 115,
        116, 117, 115,
        115, 117, 69,
        117, 39, 69,
        118, 40, 39,
        119, 120, 118,
        30, 121, 119,
        118, 120, 40,
        120, 79, 40,
        119, 121, 120,
        121, 122, 120,
        120, 122, 79,
        122, 80, 79,
        30, 21, 121,
        21, 123, 121,
        121, 123, 122,
        123, 124, 122,
        122, 124, 80,
        124, 81, 80,
        125, 37, 36,
        126, 127, 125,
        29, 128, 126,
        125, 127, 37,
        127, 91, 37,
        126, 128, 127,
        128, 129, 127,
        127, 129, 91,
        129, 92, 91,
        29, 18, 128,
        18, 130, 128,
        128, 130, 129,
        130, 131, 129,
        129, 131, 92,
        131, 33, 92,
        132, 34, 33,
        133, 134, 132,
        28, 135, 133,
        132, 134, 34,
        134, 102, 34,
        133, 135, 134,
        135, 136, 134,
        134, 136, 102,
        136, 103, 102,
        28, 15, 135,
        15, 137, 135,
        135, 137, 136,
        137, 138, 136,
        136, 138, 103,
        138, 45, 103,
        110, 111, 42,
        109, 139, 110,
        27, 140, 109,
        110, 139, 111,
        139, 112, 111,
        109, 140, 139,
        140, 141, 139,
        139, 141, 112,
        141, 31, 112,
        27, 26, 140,
        26, 142, 140,
        140, 142, 141,
        142, 143, 141,
        141, 143, 31,
        143, 22, 31,
        117, 118, 39,
        116, 144, 117,
        24, 145, 116,
        117, 144, 118,
        144, 119, 118,
        116, 145, 144,
        145, 146, 144,
        144, 146, 119,
        146, 30, 119,
        24, 23, 145,
        23, 147, 145,
        145, 147, 146,
        147, 148, 146,
        146, 148, 30,
        148, 19, 30,
        124, 149, 81,
        123, 150, 124,
        21, 151, 123,
        124, 150, 149,
        150, 152, 149,
        123, 151, 150,
        151, 153, 150,
        150, 153, 152,
        153, 154, 152,
        21, 20, 151,
        20, 155, 151,
        151, 155, 153,
        155, 156, 153,
        153, 156, 154,
        156, 157, 154,
        131, 132, 33,
        130, 158, 131,
        18, 159, 130,
        131, 158, 132,
        158, 133, 132,
        130, 159, 158,
        159, 160, 158,
        158, 160, 133,
        160, 28, 133,
        18, 17, 159,
        17, 161, 159,
        159, 161, 160,
        161, 162, 160,
        160, 162, 28,
        162, 3, 28,
        138, 104, 45,
        137, 163, 138,
        15, 164, 137,
        138, 163, 104,
        163, 105, 104,
        137, 164, 163,
        164, 165, 163,
        163, 165, 105,
        165, 32, 105,
        15, 5, 164,
        5, 166, 164,
        164, 166, 165,
        166, 167, 165,
        165, 167, 32,
        167, 25, 32,
        168, 26, 25,
        169, 170, 168,
        14, 171, 169,
        168, 170, 26,
        170, 142, 26,
        169, 171, 170,
        171, 172, 170,
        170, 172, 142,
        172, 143, 142,
        14, 13, 171,
        13, 173, 171,
        171, 173, 172,
        173, 174, 172,
        172, 174, 143,
        174, 22, 143,
        175, 23, 22,
        176, 177, 175,
        11, 178, 176,
        175, 177, 23,
        177, 147, 23,
        176, 178, 177,
        178, 179, 177,
        177, 179, 147,
        179, 148, 147,
        11, 10, 178,
        10, 180, 178,
        178, 180, 179,
        180, 181, 179,
        179, 181, 148,
        181, 19, 148,
        182, 20, 19,
        183, 184, 182,
        8, 185, 183,
        182, 184, 20,
        184, 155, 20,
        183, 185, 184,
        185, 186, 184,
        184, 186, 155,
        186, 156, 155,
        8, 7, 185,
        7, 187, 185,
        185, 187, 186,
        187, 188, 186,
        186, 188, 156,
        188, 157, 156,
        167, 189, 25,
        166, 190, 167,
        5, 191, 166,
        167, 190, 189,
        190, 192, 189,
        166, 191, 190,
        191, 193, 190,
        190, 193, 192,
        193, 194, 192,
        5, 4, 191,
        4, 195, 191,
        191, 195, 193,
        195, 196, 193,
        193, 196, 194,
        196, 197, 194,
        198, 17, 16,
        199, 200, 198,
        2, 201, 199,
        198, 200, 17,
        200, 161, 17,
        199, 201, 200,
        201, 202, 200,
        200, 202, 161,
        202, 162, 161,
        2, 1, 201,
        1, 203, 201,
        201, 203, 202,
        203, 204, 202,
        202, 204, 162,
        204, 3, 162,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::Cone(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
        { { 0.000000f, -0.500000f, -0.500000f }, { -0.000000f, -0.514200f, -0.857700f }, { 0.250000f , 0.490000f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.250000f , 0.250000f } },
        { { 0.049009f, -0.500000f, -0.497592f }, { 0.084100f, -0.514200f, -0.853600f }, { 0.273524f , 0.488844f } },
        { { 0.097545f, -0.500000f, -0.490393f }, { 0.167300f, -0.514200f, -0.841200f }, { 0.296822f , 0.485388f } },
        { { 0.145142f, -0.500000f, -0.478470f }, { 0.249000f, -0.514200f, -0.820800f }, { 0.319668f , 0.479666f } },
        { { 0.191342f, -0.500000f, -0.461940f }, { 0.328200f, -0.514200f, -0.792400f }, { 0.341844f , 0.471731f } },
        { { 0.235698f, -0.500000f, -0.440961f }, { 0.404300f, -0.514200f, -0.756400f }, { 0.363135f , 0.461661f } },
        { { 0.277785f, -0.500000f, -0.415735f }, { 0.476500f, -0.514200f, -0.713100f }, { 0.383337f , 0.449553f } },
        { { 0.317197f, -0.500000f, -0.386505f }, { 0.544100f, -0.514100f, -0.663000f }, { 0.402254f , 0.435522f } },
        { { 0.353553f, -0.500000f, -0.353553f }, { 0.606500f, -0.514200f, -0.606500f }, { 0.419706f , 0.419706f } },
        { { 0.386505f, -0.500000f, -0.317197f }, { 0.663000f, -0.514200f, -0.544100f }, { 0.435522f , 0.402254f } },
        { { 0.415735f, -0.500000f, -0.277785f }, { 0.713100f, -0.514200f, -0.476500f }, { 0.449553f , 0.383337f } },
        { { 0.440961f, -0.500000f, -0.235698f }, { 0.756400f, -0.514200f, -0.404300f }, { 0.461661f , 0.363135f } },
        { { 0.461940f, -0.500000f, -0.191342f }, { 0.792400f, -0.514200f, -0.328200f }, { 0.471731f , 0.341844f } },
        { { 0.478470f, -0.500000f, -0.145142f }, { 0.820800f, -0.514200f, -0.249000f }, { 0.479666f , 0.319668f } },
        { { 0.490393f, -0.500000f, -0.097545f }, { 0.841200f, -0.514200f, -0.167300f }, { 0.485388f , 0.296822f } },
        { { 0.497592f, -0.500000f, -0.049009f }, { 0.853600f, -0.514100f, -0.084100f }, { 0.488844f , 0.273524f } },
        { { 0.500000f, -0.500000f, 0.000000f }, { 0.857700f, -0.514200f, -0.000000f }, { 0.490000f , 0.250000f } },
        { { 0.497592f, -0.500000f, 0.049009f }, { 0.853600f, -0.514200f, 0.084100f }, { 0.488844f , 0.226476f } },
        { { 0.490393f, -0.500000f, 0.097545f }, { 0.841200f, -0.514200f, 0.167300f }, { 0.485388f , 0.203178f } },
        { { 0.478470f, -0.500000f, 0.145142f }, { 0.820800f, -0.514200f, 0.249000f }, { 0.479666f , 0.180332f } },
        { { 0.461940f, -0.500000f, 0.191342f }, { 0.792400f, -0.514200f, 0.328200f }, { 0.471731f , 0.158156f } },
        { { 0.440961f, -0.500000f, 0.235698f }, { 0.756400f, -0.514200f, 0.404300f }, { 0.461661f , 0.136865f } },
        { { 0.415735f, -0.500000f, 0.277785f }, { 0.713100f, -0.514200f, 0.476500f }, { 0.449553f , 0.116663f } },
        { { 0.386505f, -0.500000f, 0.317197f }, { 0.663000f, -0.514100f, 0.544100f }, { 0.435522f , 0.097746f } },
        { { 0.353553f, -0.500000f, 0.353553f }, { 0.606500f, -0.514200f, 0.606500f }, { 0.419706f , 0.080294f } },
        { { 0.317197f, -0.500000f, 0.386505f }, { 0.544100f, -0.514200f, 0.663000f }, { 0.402254f , 0.064478f } },
        { { 0.277785f, -0.500000f, 0.415735f }, { 0.476500f, -0.514200f, 0.713100f }, { 0.383337f , 0.050447f } },
        { { 0.235698f, -0.500000f, 0.440961f }, { 0.404300f, -0.514200f, 0.756400f }, { 0.363135f , 0.038339f } },
        { { 0.191342f, -0.500000f, 0.461940f }, { 0.328200f, -0.514200f, 0.792400f }, { 0.341844f , 0.028269f } },
        { { 0.145142f, -0.500000f, 0.478470f }, { 0.249000f, -0.514200f, 0.820800f }, { 0.319668f , 0.020334f } },
        { { 0.097545f, -0.500000f, 0.490393f }, { 0.167300f, -0.514200f, 0.841200f }, { 0.296822f , 0.014612f } },
        { { 0.049009f, -0.500000f, 0.497592f }, { 0.084100f, -0.514100f, 0.853600f }, { 0.273524f , 0.011156f } },
        { { 0.000000f, -0.500000f, 0.500000f }, { -0.000000f, -0.514200f, 0.857700f }, { 0.250000f , 0.010000f } },
        { { -0.049009f, -0.500000f, 0.497592f }, { -0.084100f, -0.514200f, 0.853600f }, { 0.226476f , 0.011156f } },
        { { -0.097545f, -0.500000f, 0.490393f }, { -0.167300f, -0.514200f, 0.841200f }, { 0.203178f , 0.014612f } },
        { { -0.145142f, -0.500000f, 0.478470f }, { -0.249000f, -0.514200f, 0.820800f }, { 0.180332f , 0.020334f } },
        { { -0.191342f, -0.500000f, 0.461940f }, { -0.328200f, -0.514200f, 0.792400f }, { 0.158156f , 0.028269f } },
        { { -0.235698f, -0.500000f, 0.440961f }, { -0.404300f, -0.514200f, 0.756400f }, { 0.136865f , 0.038339f } },
        { { -0.277785f, -0.500000f, 0.415735f }, { -0.476500f, -0.514200f, 0.713100f }, { 0.116663f , 0.050447f } },
        { { -0.317197f, -0.500000f, 0.386505f }, { -0.544100f, -0.514100f, 0.663000f }, { 0.097746f , 0.064478f } },
        { { -0.353553f, -0.500000f, 0.353553f }, { -0.606500f, -0.514200f, 0.606500f }, { 0.080294f , 0.080294f } },
        { { -0.386505f, -0.500000f, 0.317197f }, { -0.663000f, -0.514200f, 0.544100f }, { 0.064478f , 0.097746f } },
        { { -0.415735f, -0.500000f, 0.277785f }, { -0.713100f, -0.514200f, 0.476500f }, { 0.050447f , 0.116663f } },
        { { -0.440961f, -0.500000f, 0.235698f }, { -0.756400f, -0.514200f, 0.404300f }, { 0.038339f , 0.136865f } },
        { { -0.461940f, -0.500000f, 0.191342f }, { -0.792400f, -0.514200f, 0.328200f }, { 0.028269f , 0.158156f } },
        { { -0.478470f, -0.500000f, 0.145142f }, { -0.820800f, -0.514200f, 0.249000f }, { 0.020334f , 0.180332f } },
        { { -0.490393f, -0.500000f, 0.097545f }, { -0.841200f, -0.514200f, 0.167300f }, { 0.014612f , 0.203178f } },
        { { -0.497592f, -0.500000f, 0.049009f }, { -0.853600f, -0.514100f, 0.084100f }, { 0.011156f , 0.226476f } },
        { { -0.500000f, -0.500000f, 0.000000f }, { -0.857700f, -0.514200f, -0.000000f }, { 0.010000f , 0.250000f } },
        { { -0.497592f, -0.500000f, -0.049009f }, { -0.853600f, -0.514200f, -0.084100f }, { 0.011156f , 0.273524f } },
        { { -0.490393f, -0.500000f, -0.097545f }, { -0.841200f, -0.514200f, -0.167300f }, { 0.014612f , 0.296822f } },
        { { -0.478470f, -0.500000f, -0.145142f }, { -0.820800f, -0.514200f, -0.249000f }, { 0.020334f , 0.319668f } },
        { { -0.461940f, -0.500000f, -0.191342f }, { -0.792400f, -0.514200f, -0.328200f }, { 0.028269f , 0.341844f } },
        { { -0.440961f, -0.500000f, -0.235698f }, { -0.756400f, -0.514200f, -0.404300f }, { 0.038339f , 0.363135f } },
        { { -0.415735f, -0.500000f, -0.277785f }, { -0.713100f, -0.514200f, -0.476500f }, { 0.050447f , 0.383337f } },
        { { -0.386505f, -0.500000f, -0.317197f }, { -0.663000f, -0.514100f, -0.544100f }, { 0.064478f , 0.402254f } },
        { { -0.353553f, -0.500000f, -0.353553f }, { -0.606500f, -0.514200f, -0.606500f }, { 0.080294f , 0.419706f } },
        { { -0.317197f, -0.500000f, -0.386505f }, { -0.544100f, -0.514200f, -0.663000f }, { 0.097746f , 0.435522f } },
        { { -0.277785f, -0.500000f, -0.415735f }, { -0.476500f, -0.514200f, -0.713100f }, { 0.116663f , 0.449553f } },
        { { -0.235698f, -0.500000f, -0.440961f }, { -0.404300f, -0.514200f, -0.756400f }, { 0.136865f , 0.461661f } },
        { { -0.191342f, -0.500000f, -0.461940f }, { -0.328200f, -0.514200f, -0.792400f }, { 0.158156f , 0.471731f } },
        { { -0.145142f, -0.500000f, -0.478470f }, { -0.249000f, -0.514200f, -0.820800f }, { 0.180332f , 0.479666f } },
        { { -0.097545f, -0.500000f, -0.490393f }, { -0.167300f, -0.514200f, -0.841200f }, { 0.203178f , 0.485388f } },
        { { 0.049009f, -0.500000f, 0.497592f }, { 0.084100f, -0.514100f, 0.853600f }, { 0.773524f , 0.011156f } },
        { { -0.497592f, -0.500000f, 0.049009f }, { -0.853600f, -0.514100f, 0.084100f }, { 0.511156f , 0.226476f } },
        { { -0.049009f, -0.500000f, -0.497592f }, { -0.084100f, -0.514100f, -0.853600f }, { 0.726476f , 0.488844f } },
        { { -0.049009f, -0.500000f, -0.497592f }, { -0.084100f, -0.514100f, -0.853600f }, { 0.226476f , 0.488844f } },
        { { 0.000000f, -0.500000f, -0.500000f }, { -0.000000f, -0.514200f, -0.857700f }, { 0.750000f , 0.490000f } },
        { { 0.049009f, -0.500000f, -0.497592f }, { 0.084100f, -0.514200f, -0.853600f }, { 0.773524f , 0.488844f } },
        { { 0.097545f, -0.500000f, -0.490393f }, { 0.167300f, -0.514200f, -0.841200f }, { 0.796822f , 0.485388f } },
        { { 0.145142f, -0.500000f, -0.478470f }, { 0.249000f, -0.514200f, -0.820800f }, { 0.819668f , 0.479666f } },
        { { 0.191342f, -0.500000f, -0.461940f }, { 0.328200f, -0.514200f, -0.792400f }, { 0.841844f , 0.471731f } },
        { { 0.235698f, -0.500000f, -0.440961f }, { 0.404300f, -0.514200f, -0.756400f }, { 0.863135f , 0.461661f } },
        { { 0.277785f, -0.500000f, -0.415735f }, { 0.476500f, -0.514200f, -0.713100f }, { 0.883337f , 0.449553f } },
        { { 0.317197f, -0.500000f, -0.386505f }, { 0.544100f, -0.514100f, -0.663000f }, { 0.902254f , 0.435522f } },
        { { 0.353553f, -0.500000f, -0.353553f }, { 0.606500f, -0.514200f, -0.606500f }, { 0.919706f , 0.419706f } },
        { { 0.386505f, -0.500000f, -0.317197f }, { 0.663000f, -0.514200f, -0.544100f }, { 0.935522f , 0.402254f } },
        { { 0.415735f, -0.500000f, -0.277785f }, { 0.713100f, -0.514200f, -0.476500f }, { 0.949553f , 0.383337f } },
        { { 0.440961f, -0.500000f, -0.235698f }, { 0.756400f, -0.514200f, -0.404300f }, { 0.961661f , 0.363135f } },
        { { 0.461940f, -0.500000f, -0.191342f }, { 0.792400f, -0.514200f, -0.328200f }, { 0.971731f , 0.341844f } },
        { { 0.478470f, -0.500000f, -0.145142f }, { 0.820800f, -0.514200f, -0.249000f }, { 0.979666f , 0.319668f } },
        { { 0.490393f, -0.500000f, -0.097545f }, { 0.841200f, -0.514200f, -0.167300f }, { 0.985388f , 0.296822f } },
        { { 0.497592f, -0.500000f, -0.049009f }, { 0.853600f, -0.514100f, -0.084100f }, { 0.988844f , 0.273524f } },
        { { 0.500000f, -0.500000f, 0.000000f }, { 0.857700f, -0.514200f, -0.000000f }, { 0.990000f , 0.250000f } },
        { { 0.497592f, -0.500000f, 0.049009f }, { 0.853600f, -0.514200f, 0.084100f }, { 0.988844f , 0.226476f } },
        { { 0.490393f, -0.500000f, 0.097545f }, { 0.841200f, -0.514200f, 0.167300f }, { 0.985388f , 0.203178f } },
        { { 0.478470f, -0.500000f, 0.145142f }, { 0.820800f, -0.514200f, 0.249000f }, { 0.979666f , 0.180332f } },
        { { 0.461940f, -0.500000f, 0.191342f }, { 0.792400f, -0.514200f, 0.328200f }, { 0.971731f , 0.158156f } },
        { { 0.440961f, -0.500000f, 0.235698f }, { 0.756400f, -0.514200f, 0.404300f }, { 0.961661f , 0.136865f } },
        { { 0.415735f, -0.500000f, 0.277785f }, { 0.713100f, -0.514200f, 0.476500f }, { 0.949553f , 0.116663f } },
        { { 0.386505f, -0.500000f, 0.317197f }, { 0.663000f, -0.514100f, 0.544100f }, { 0.935522f , 0.097746f } },
        { { 0.353553f, -0.500000f, 0.353553f }, { 0.606500f, -0.514200f, 0.606500f }, { 0.919706f , 0.080294f } },
        { { 0.317197f, -0.500000f, 0.386505f }, { 0.544100f, -0.514200f, 0.663000f }, { 0.902254f , 0.064478f } },
        { { 0.277785f, -0.500000f, 0.415735f }, { 0.476500f, -0.514200f, 0.713100f }, { 0.883337f , 0.050447f } },
        { { 0.235698f, -0.500000f, 0.440961f }, { 0.404300f, -0.514200f, 0.756400f }, { 0.863135f , 0.038339f } },
        { { 0.191342f, -0.500000f, 0.461940f }, { 0.328200f, -0.514200f, 0.792400f }, { 0.841844f , 0.028269f } },
        { { 0.145142f, -0.500000f, 0.478470f }, { 0.249000f, -0.514200f, 0.820800f }, { 0.819668f , 0.020334f } },
        { { 0.097545f, -0.500000f, 0.490393f }, { 0.167300f, -0.514200f, 0.841200f }, { 0.796822f , 0.014612f } },
        { { 0.000000f, -0.500000f, 0.500000f }, { -0.000000f, -0.514200f, 0.857700f }, { 0.750000f , 0.010000f } },
        { { -0.049009f, -0.500000f, 0.497592f }, { -0.084100f, -0.514200f, 0.853600f }, { 0.726476f , 0.011156f } },
        { { -0.097545f, -0.500000f, 0.490393f }, { -0.167300f, -0.514200f, 0.841200f }, { 0.703178f , 0.014612f } },
        { { -0.145142f, -0.500000f, 0.478470f }, { -0.249000f, -0.514200f, 0.820800f }, { 0.680332f , 0.020334f } },
        { { -0.191342f, -0.500000f, 0.461940f }, { -0.328200f, -0.514200f, 0.792400f }, { 0.658156f , 0.028269f } },
        { { -0.235698f, -0.500000f, 0.440961f }, { -0.404300f, -0.514200f, 0.756400f }, { 0.636865f , 0.038339f } },
        { { -0.277785f, -0.500000f, 0.415735f }, { -0.476500f, -0.514200f, 0.713100f }, { 0.616663f , 0.050447f } },
        { { -0.317197f, -0.500000f, 0.386505f }, { -0.544100f, -0.514100f, 0.663000f }, { 0.597746f , 0.064478f } },
        { { -0.353553f, -0.500000f, 0.353553f }, { -0.606500f, -0.514200f, 0.606500f }, { 0.580294f , 0.080294f } },
        { { -0.386505f, -0.500000f, 0.317197f }, { -0.663000f, -0.514200f, 0.544100f }, { 0.564478f , 0.097746f } },
        { { -0.415735f, -0.500000f, 0.277785f }, { -0.713100f, -0.514200f, 0.476500f }, { 0.550447f , 0.116663f } },
        { { -0.440961f, -0.500000f, 0.235698f }, { -0.756400f, -0.514200f, 0.404300f }, { 0.538339f , 0.136865f } },
        { { -0.461940f, -0.500000f, 0.191342f }, { -0.792400f, -0.514200f, 0.328200f }, { 0.528269f , 0.158156f } },
        { { -0.478470f, -0.500000f, 0.145142f }, { -0.820800f, -0.514200f, 0.249000f }, { 0.520334f , 0.180332f } },
        { { -0.490393f, -0.500000f, 0.097545f }, { -0.841200f, -0.514200f, 0.167300f }, { 0.514612f , 0.203178f } },
        { { -0.500000f, -0.500000f, 0.000000f }, { -0.857700f, -0.514200f, -0.000000f }, { 0.510000f , 0.250000f } },
        { { -0.497592f, -0.500000f, -0.049009f }, { -0.853600f, -0.514200f, -0.084100f }, { 0.511156f , 0.273524f } },
        { { -0.490393f, -0.500000f, -0.097545f }, { -0.841200f, -0.514200f, -0.167300f }, { 0.514612f , 0.296822f } },
        { { -0.478470f, -0.500000f, -0.145142f }, { -0.820800f, -0.514200f, -0.249000f }, { 0.520334f , 0.319668f } },
        { { -0.461940f, -0.500000f, -0.191342f }, { -0.792400f, -0.514200f, -0.328200f }, { 0.528269f , 0.341844f } },
        { { -0.440961f, -0.500000f, -0.235698f }, { -0.756400f, -0.514200f, -0.404300f }, { 0.538339f , 0.363135f } },
        { { -0.415735f, -0.500000f, -0.277785f }, { -0.713100f, -0.514200f, -0.476500f }, { 0.550447f , 0.383337f } },
        { { -0.386505f, -0.500000f, -0.317197f }, { -0.663000f, -0.514100f, -0.544100f }, { 0.564478f , 0.402254f } },
        { { -0.353553f, -0.500000f, -0.353553f }, { -0.606500f, -0.514200f, -0.606500f }, { 0.580294f , 0.419706f } },
        { { -0.317197f, -0.500000f, -0.386505f }, { -0.544100f, -0.514200f, -0.663000f }, { 0.597746f , 0.435522f } },
        { { -0.277785f, -0.500000f, -0.415735f }, { -0.476500f, -0.514200f, -0.713100f }, { 0.616663f , 0.449553f } },
        { { -0.235698f, -0.500000f, -0.440961f }, { -0.404300f, -0.514200f, -0.756400f }, { 0.636865f , 0.461661f } },
        { { -0.191342f, -0.500000f, -0.461940f }, { -0.328200f, -0.514200f, -0.792400f }, { 0.658156f , 0.471731f } },
        { { -0.145142f, -0.500000f, -0.478470f }, { -0.249000f, -0.514200f, -0.820800f }, { 0.680332f , 0.479666f } },
        { { -0.097545f, -0.500000f, -0.490393f }, { -0.167300f, -0.514200f, -0.841200f }, { 0.703178f , 0.485388f } },
        };
        MeshIndex indices[]
        {
        0, 1, 2,
        2, 1, 3,
        3, 1, 4,
        4, 1, 5,
        5, 1, 6,
        6, 1, 7,
        7, 1, 8,
        8, 1, 9,
        9, 1, 10,
        10, 1, 11,
        11, 1, 12,
        12, 1, 13,
        13, 1, 14,
        14, 1, 15,
        15, 1, 16,
        16, 1, 17,
        17, 1, 18,
        18, 1, 19,
        19, 1, 20,
        20, 1, 21,
        21, 1, 22,
        22, 1, 23,
        23, 1, 24,
        24, 1, 25,
        25, 1, 26,
        26, 1, 27,
        27, 1, 28,
        28, 1, 29,
        29, 1, 30,
        30, 1, 31,
        31, 1, 32,
        32, 1, 33,
        33, 1, 34,
        34, 1, 35,
        35, 1, 36,
        36, 1, 37,
        37, 1, 38,
        38, 1, 39,
        39, 1, 40,
        40, 1, 41,
        41, 1, 42,
        42, 1, 43,
        43, 1, 44,
        44, 1, 45,
        45, 1, 46,
        46, 1, 47,
        47, 1, 48,
        48, 1, 49,
        49, 1, 50,
        50, 1, 51,
        51, 1, 52,
        52, 1, 53,
        53, 1, 54,
        54, 1, 55,
        55, 1, 56,
        56, 1, 57,
        57, 1, 58,
        58, 1, 59,
        59, 1, 60,
        60, 1, 61,
        61, 1, 62,
        62, 1, 63,
        64, 65, 66,
        63, 1, 67,
        67, 1, 0,
        66, 68, 69,
        69, 70, 71,
        71, 72, 73,
        73, 74, 75,
        75, 76, 77,
        77, 78, 79,
        79, 80, 81,
        81, 82, 83,
        83, 84, 85,
        85, 86, 87,
        87, 88, 89,
        89, 90, 91,
        91, 92, 93,
        93, 94, 95,
        95, 96, 97,
        97, 98, 64,
        64, 99, 100,
        100, 101, 102,
        102, 103, 104,
        104, 105, 106,
        106, 107, 108,
        108, 109, 110,
        110, 111, 112,
        112, 113, 65,
        65, 114, 115,
        115, 116, 117,
        117, 118, 119,
        119, 120, 121,
        121, 122, 123,
        123, 124, 125,
        125, 126, 127,
        127, 128, 66,
        66, 69, 71,
        71, 73, 75,
        75, 77, 79,
        79, 81, 83,
        83, 85, 87,
        87, 89, 91,
        91, 93, 95,
        95, 97, 64,
        64, 100, 102,
        102, 104, 106,
        106, 108, 110,
        110, 112, 65,
        65, 115, 117,
        117, 119, 121,
        121, 123, 125,
        125, 127, 66,
        66, 71, 75,
        75, 79, 83,
        83, 87, 91,
        91, 95, 64,
        64, 102, 106,
        106, 110, 65,
        65, 117, 121,
        121, 125, 66,
        66, 75, 83,
        83, 91, 64,
        64, 106, 65,
        65, 121, 66,
        66, 83, 64,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh Mesh::ConeNoBase(ID3D11Device* dev)
    {
        MeshVertex vertices[]
        {
        { { 0.000000f, -0.500000f, -0.500000f }, { -0.000000f, 0.447200f, -0.894400f }, { 0.250000f , 0.490000f } },
        { { 0.000000f, 0.500000f, 0.000000f }, { -0.000000f, 1.000000f, -0.000000f }, { 0.250000f , 0.250000f } },
        { { 0.049009f, -0.500000f, -0.497592f }, { 0.087700f, 0.447200f, -0.890100f }, { 0.273524f , 0.488844f } },
        { { 0.097545f, -0.500000f, -0.490393f }, { 0.174500f, 0.447200f, -0.877200f }, { 0.296822f , 0.485388f } },
        { { 0.145142f, -0.500000f, -0.478470f }, { 0.259600f, 0.447200f, -0.855900f }, { 0.319668f , 0.479666f } },
        { { 0.191342f, -0.500000f, -0.461940f }, { 0.342300f, 0.447200f, -0.826300f }, { 0.341844f , 0.471731f } },
        { { 0.235698f, -0.500000f, -0.440961f }, { 0.421600f, 0.447200f, -0.788800f }, { 0.363135f , 0.461661f } },
        { { 0.277785f, -0.500000f, -0.415735f }, { 0.496900f, 0.447200f, -0.743700f }, { 0.383337f , 0.449553f } },
        { { 0.317197f, -0.500000f, -0.386505f }, { 0.567400f, 0.447200f, -0.691400f }, { 0.402254f , 0.435522f } },
        { { 0.353553f, -0.500000f, -0.353553f }, { 0.632500f, 0.447200f, -0.632500f }, { 0.419706f , 0.419706f } },
        { { 0.386505f, -0.500000f, -0.317197f }, { 0.691400f, 0.447200f, -0.567400f }, { 0.435522f , 0.402254f } },
        { { 0.415735f, -0.500000f, -0.277785f }, { 0.743700f, 0.447200f, -0.496900f }, { 0.449553f , 0.383337f } },
        { { 0.440961f, -0.500000f, -0.235698f }, { 0.788800f, 0.447200f, -0.421600f }, { 0.461661f , 0.363135f } },
        { { 0.461940f, -0.500000f, -0.191342f }, { 0.826300f, 0.447200f, -0.342300f }, { 0.471731f , 0.341844f } },
        { { 0.478470f, -0.500000f, -0.145142f }, { 0.855900f, 0.447200f, -0.259600f }, { 0.479666f , 0.319668f } },
        { { 0.490393f, -0.500000f, -0.097545f }, { 0.877200f, 0.447200f, -0.174500f }, { 0.485388f , 0.296822f } },
        { { 0.497592f, -0.500000f, -0.049009f }, { 0.890100f, 0.447200f, -0.087700f }, { 0.488844f , 0.273524f } },
        { { 0.500000f, -0.500000f, 0.000000f }, { 0.894400f, 0.447200f, -0.000000f }, { 0.490000f , 0.250000f } },
        { { 0.497592f, -0.500000f, 0.049009f }, { 0.890100f, 0.447200f, 0.087700f }, { 0.488844f , 0.226476f } },
        { { 0.490393f, -0.500000f, 0.097545f }, { 0.877200f, 0.447200f, 0.174500f }, { 0.485388f , 0.203178f } },
        { { 0.478470f, -0.500000f, 0.145142f }, { 0.855900f, 0.447200f, 0.259600f }, { 0.479666f , 0.180332f } },
        { { 0.461940f, -0.500000f, 0.191342f }, { 0.826300f, 0.447200f, 0.342300f }, { 0.471731f , 0.158156f } },
        { { 0.440961f, -0.500000f, 0.235698f }, { 0.788800f, 0.447200f, 0.421600f }, { 0.461661f , 0.136865f } },
        { { 0.415735f, -0.500000f, 0.277785f }, { 0.743700f, 0.447200f, 0.496900f }, { 0.449553f , 0.116663f } },
        { { 0.386505f, -0.500000f, 0.317197f }, { 0.691400f, 0.447200f, 0.567400f }, { 0.435522f , 0.097746f } },
        { { 0.353553f, -0.500000f, 0.353553f }, { 0.632500f, 0.447200f, 0.632500f }, { 0.419706f , 0.080294f } },
        { { 0.317197f, -0.500000f, 0.386505f }, { 0.567400f, 0.447200f, 0.691400f }, { 0.402254f , 0.064478f } },
        { { 0.277785f, -0.500000f, 0.415735f }, { 0.496900f, 0.447200f, 0.743700f }, { 0.383337f , 0.050447f } },
        { { 0.235698f, -0.500000f, 0.440961f }, { 0.421600f, 0.447200f, 0.788800f }, { 0.363135f , 0.038339f } },
        { { 0.191342f, -0.500000f, 0.461940f }, { 0.342300f, 0.447200f, 0.826300f }, { 0.341844f , 0.028269f } },
        { { 0.145142f, -0.500000f, 0.478470f }, { 0.259600f, 0.447200f, 0.855900f }, { 0.319668f , 0.020334f } },
        { { 0.097545f, -0.500000f, 0.490393f }, { 0.174500f, 0.447200f, 0.877200f }, { 0.296822f , 0.014612f } },
        { { 0.049009f, -0.500000f, 0.497592f }, { 0.087700f, 0.447200f, 0.890100f }, { 0.273524f , 0.011156f } },
        { { 0.000000f, -0.500000f, 0.500000f }, { -0.000000f, 0.447200f, 0.894400f }, { 0.250000f , 0.010000f } },
        { { -0.049009f, -0.500000f, 0.497592f }, { -0.087700f, 0.447200f, 0.890100f }, { 0.226476f , 0.011156f } },
        { { -0.097545f, -0.500000f, 0.490393f }, { -0.174500f, 0.447200f, 0.877200f }, { 0.203178f , 0.014612f } },
        { { -0.145142f, -0.500000f, 0.478470f }, { -0.259600f, 0.447200f, 0.855900f }, { 0.180332f , 0.020334f } },
        { { -0.191342f, -0.500000f, 0.461940f }, { -0.342300f, 0.447200f, 0.826300f }, { 0.158156f , 0.028269f } },
        { { -0.235698f, -0.500000f, 0.440961f }, { -0.421600f, 0.447200f, 0.788800f }, { 0.136865f , 0.038339f } },
        { { -0.277785f, -0.500000f, 0.415735f }, { -0.496900f, 0.447200f, 0.743700f }, { 0.116663f , 0.050447f } },
        { { -0.317197f, -0.500000f, 0.386505f }, { -0.567400f, 0.447200f, 0.691400f }, { 0.097746f , 0.064478f } },
        { { -0.353553f, -0.500000f, 0.353553f }, { -0.632500f, 0.447200f, 0.632500f }, { 0.080294f , 0.080294f } },
        { { -0.386505f, -0.500000f, 0.317197f }, { -0.691400f, 0.447200f, 0.567400f }, { 0.064478f , 0.097746f } },
        { { -0.415735f, -0.500000f, 0.277785f }, { -0.743700f, 0.447200f, 0.496900f }, { 0.050447f , 0.116663f } },
        { { -0.440961f, -0.500000f, 0.235698f }, { -0.788800f, 0.447200f, 0.421600f }, { 0.038339f , 0.136865f } },
        { { -0.461940f, -0.500000f, 0.191342f }, { -0.826300f, 0.447200f, 0.342300f }, { 0.028269f , 0.158156f } },
        { { -0.478470f, -0.500000f, 0.145142f }, { -0.855900f, 0.447200f, 0.259600f }, { 0.020334f , 0.180332f } },
        { { -0.490393f, -0.500000f, 0.097545f }, { -0.877200f, 0.447200f, 0.174500f }, { 0.014612f , 0.203178f } },
        { { -0.497592f, -0.500000f, 0.049009f }, { -0.890100f, 0.447200f, 0.087700f }, { 0.011156f , 0.226476f } },
        { { -0.500000f, -0.500000f, 0.000000f }, { -0.894400f, 0.447200f, -0.000000f }, { 0.010000f , 0.250000f } },
        { { -0.497592f, -0.500000f, -0.049009f }, { -0.890100f, 0.447200f, -0.087700f }, { 0.011156f , 0.273524f } },
        { { -0.490393f, -0.500000f, -0.097545f }, { -0.877200f, 0.447200f, -0.174500f }, { 0.014612f , 0.296822f } },
        { { -0.478470f, -0.500000f, -0.145142f }, { -0.855900f, 0.447200f, -0.259600f }, { 0.020334f , 0.319668f } },
        { { -0.461940f, -0.500000f, -0.191342f }, { -0.826300f, 0.447200f, -0.342300f }, { 0.028269f , 0.341844f } },
        { { -0.440961f, -0.500000f, -0.235698f }, { -0.788800f, 0.447200f, -0.421600f }, { 0.038339f , 0.363135f } },
        { { -0.415735f, -0.500000f, -0.277785f }, { -0.743700f, 0.447200f, -0.496900f }, { 0.050447f , 0.383337f } },
        { { -0.386505f, -0.500000f, -0.317197f }, { -0.691400f, 0.447200f, -0.567400f }, { 0.064478f , 0.402254f } },
        { { -0.353553f, -0.500000f, -0.353553f }, { -0.632500f, 0.447200f, -0.632500f }, { 0.080294f , 0.419706f } },
        { { -0.317197f, -0.500000f, -0.386505f }, { -0.567400f, 0.447200f, -0.691400f }, { 0.097746f , 0.435522f } },
        { { -0.277785f, -0.500000f, -0.415735f }, { -0.496900f, 0.447200f, -0.743700f }, { 0.116663f , 0.449553f } },
        { { -0.235698f, -0.500000f, -0.440961f }, { -0.421600f, 0.447200f, -0.788800f }, { 0.136865f , 0.461661f } },
        { { -0.191342f, -0.500000f, -0.461940f }, { -0.342300f, 0.447200f, -0.826300f }, { 0.158156f , 0.471731f } },
        { { -0.145142f, -0.500000f, -0.478470f }, { -0.259600f, 0.447200f, -0.855900f }, { 0.180332f , 0.479666f } },
        { { -0.097545f, -0.500000f, -0.490393f }, { -0.174500f, 0.447200f, -0.877200f }, { 0.203178f , 0.485388f } },
        { { -0.049009f, -0.500000f, -0.497592f }, { -0.087700f, 0.447200f, -0.890100f }, { 0.226476f , 0.488844f } },
        };
        MeshIndex indices[]
        {
        0, 1, 2,
        2, 1, 3,
        3, 1, 4,
        4, 1, 5,
        5, 1, 6,
        6, 1, 7,
        7, 1, 8,
        8, 1, 9,
        9, 1, 10,
        10, 1, 11,
        11, 1, 12,
        12, 1, 13,
        13, 1, 14,
        14, 1, 15,
        15, 1, 16,
        16, 1, 17,
        17, 1, 18,
        18, 1, 19,
        19, 1, 20,
        20, 1, 21,
        21, 1, 22,
        22, 1, 23,
        23, 1, 24,
        24, 1, 25,
        25, 1, 26,
        26, 1, 27,
        27, 1, 28,
        28, 1, 29,
        29, 1, 30,
        30, 1, 31,
        31, 1, 32,
        32, 1, 33,
        33, 1, 34,
        34, 1, 35,
        35, 1, 36,
        36, 1, 37,
        37, 1, 38,
        38, 1, 39,
        39, 1, 40,
        40, 1, 41,
        41, 1, 42,
        42, 1, 43,
        43, 1, 44,
        44, 1, 45,
        45, 1, 46,
        46, 1, 47,
        47, 1, 48,
        48, 1, 49,
        49, 1, 50,
        50, 1, 51,
        51, 1, 52,
        52, 1, 53,
        53, 1, 54,
        54, 1, 55,
        55, 1, 56,
        56, 1, 57,
        57, 1, 58,
        58, 1, 59,
        59, 1, 60,
        60, 1, 61,
        61, 1, 62,
        62, 1, 63,
        63, 1, 64,
        64, 1, 0,
        };

        return Mesh{ dev, vertices, indices };
    }
    Mesh::Mesh(ID3D11Device* dev, std::span<const MeshVertex> vertices, std::span<const MeshIndex> indices)
        : m_vertices{}
        , m_indices{}
        , m_vertex_count{ static_cast<UINT>(vertices.size()) }
        , m_index_count{ static_cast<UINT>(indices.size()) }

    {
        // upload vertices to the GPU
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = static_cast<UINT>(vertices.size_bytes());
            desc.Usage = D3D11_USAGE_IMMUTABLE;
            desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
            desc.CPUAccessFlags = 0;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            D3D11_SUBRESOURCE_DATA data{};
            data.pSysMem = vertices.data();
            data.SysMemPitch = 0;
            data.SysMemSlicePitch = 0;
            qk_CheckHR(dev->CreateBuffer(&desc, &data, m_vertices.ReleaseAndGetAddressOf()));
        }

        // upload indices to the GPU
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = static_cast<UINT>(indices.size_bytes());
            desc.Usage = D3D11_USAGE_IMMUTABLE;
            desc.BindFlags = D3D11_BIND_INDEX_BUFFER;
            desc.CPUAccessFlags = 0;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            D3D11_SUBRESOURCE_DATA data{};
            data.pSysMem = indices.data();
            data.SysMemPitch = 0;
            data.SysMemSlicePitch = 0;
            qk_CheckHR(dev->CreateBuffer(&desc, &data, m_indices.ReleaseAndGetAddressOf()));
        }
    }

    class Texture
    {
    public:
        static Texture AlbedoBlack(ID3D11Device* dev);
        static Texture AlbedoWhite(ID3D11Device* dev);
        static Texture AlbedoPink(ID3D11Device* dev);
        static Texture AlbedoChecker(ID3D11Device* dev);
    private:
        constexpr static int ALBEDO_DIM{ 64 };
    public:
        Texture(ID3D11Device* dev, int w, int h, int channels, const void* data);
        ~Texture() = default;
        Texture(const Texture&) = delete;
        Texture(Texture&&) noexcept = default;
        Texture& operator=(const Texture&) = delete;
        Texture& operator=(Texture&&) noexcept = default;
    public:
        ID3D11ShaderResourceView* SRV() const noexcept { return m_srv.Get(); }
    private:
        wrl::ComPtr<ID3D11Texture2D> m_texture;
        wrl::ComPtr<ID3D11ShaderResourceView> m_srv;
    };
    Texture Texture::AlbedoBlack(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int i{}; i < DIM * DIM; i++)
        {
            pixels[i] =
            {
                .r = 0,
                .g = 0,
                .b = 0,
                .a = std::numeric_limits<std::uint8_t>::max(),
            };
        }

        return Texture{ dev, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture Texture::AlbedoWhite(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int i{}; i < DIM * DIM; i++)
        {
            pixels[i] =
            {
                .r = std::numeric_limits<std::uint8_t>::max(),
                .g = std::numeric_limits<std::uint8_t>::max(),
                .b = std::numeric_limits<std::uint8_t>::max(),
                .a = std::numeric_limits<std::uint8_t>::max(),
            };
        }

        return Texture{ dev, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture Texture::AlbedoPink(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int i{}; i < DIM * DIM; i++)
        {
            pixels[i] =
            {
                .r = std::numeric_limits<std::uint8_t>::max(),
                .g = 0,
                .b = std::numeric_limits<std::uint8_t>::max(),
                .a = std::numeric_limits<std::uint8_t>::max(),
            };
        }

        return Texture{ dev, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture Texture::AlbedoChecker(ID3D11Device* dev)
    {
        constexpr int CHANNELS{ 4 };
        constexpr int DIM{ ALBEDO_DIM };
        constexpr int HALF_DIM{ DIM / 2 };

        struct Pixel
        {
            std::uint8_t r, g, b, a;
        };

        auto pixels{ std::make_unique<Pixel[]>(DIM * DIM) };

        for (int row{}; row < DIM; row++)
        {
            for (int col{}; col < DIM; col++)
            {
                bool is_less_half_on_row{ row < HALF_DIM };
                bool is_less_half_on_col{ col < HALF_DIM };
                int idx{ row * DIM + col };
                if (is_less_half_on_row != is_less_half_on_col) // logical xor
                {
                    pixels[idx] =
                    {
                        .r = 0,
                        .g = 0,
                        .b = 0,
                        .a = std::numeric_limits<std::uint8_t>::max(),
                    };
                }
                else
                {
                    pixels[idx] =
                    {
                        .r = std::numeric_limits<std::uint8_t>::max(),
                        .g = std::numeric_limits<std::uint8_t>::max(),
                        .b = std::numeric_limits<std::uint8_t>::max(),
                        .a = std::numeric_limits<std::uint8_t>::max(),
                    };
                }
            }
        }

        return Texture{ dev, DIM, DIM, CHANNELS, pixels.get() };
    }
    Texture::Texture(ID3D11Device* dev, int w, int h, int channels, const void* data)
        : m_texture{}
        , m_srv{}
    {
        DXGI_FORMAT format{};
        switch (channels)
        {
        case 1: { format = DXGI_FORMAT_R8_UNORM; } break;
        case 2: { format = DXGI_FORMAT_R8G8_UNORM; } break;
        case 4: { format = DXGI_FORMAT_R8G8B8A8_UNORM; } break;
        default: { qk_Unreachable(); } break;
        }

        D3D11_TEXTURE2D_DESC desc{};
        desc.Width = static_cast<UINT>(w);
        desc.Height = static_cast<UINT>(h);
        desc.MipLevels = 1; // TODO: generate mip chain
        desc.ArraySize = 1;
        desc.Format = format;
        desc.SampleDesc = { .Count = 1, .Quality = 0 };
        desc.Usage = D3D11_USAGE_IMMUTABLE;
        desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
        desc.CPUAccessFlags = 0;
        desc.MiscFlags = 0;
        D3D11_SUBRESOURCE_DATA initial_data{};
        initial_data.pSysMem = data;
        initial_data.SysMemPitch = w * channels;
        qk_CheckHR(dev->CreateTexture2D(&desc, &initial_data, m_texture.ReleaseAndGetAddressOf()));
        qk_CheckHR(dev->CreateShaderResourceView(m_texture.Get(), nullptr, m_srv.ReleaseAndGetAddressOf()));
    }

    class OpaquePass
    {
    public:
        OpaquePass(ID3D11Device* dev, ID3D11DeviceContext* ctx, const std::vector<Mesh>& meshes, const std::vector<Texture>& textures);
        ~OpaquePass() = default;
        OpaquePass(const OpaquePass&) = delete;
        OpaquePass(OpaquePass&&) noexcept = delete;
        OpaquePass& operator=(const OpaquePass&) = delete;
        OpaquePass& operator=(OpaquePass&&) noexcept = delete;
    public:
        void Render(int w, int h, ID3D11RenderTargetView* rtv, ID3D11DepthStencilView* dsv, const Scene& scene);
    private:
        ID3D11Device* m_dev;
        ID3D11DeviceContext* m_ctx;
        const std::vector<Mesh>& m_meshes;
        const std::vector<Texture>& m_textures;
        D3D11_VIEWPORT m_viewport;
        wrl::ComPtr<ID3D11VertexShader> m_vs;
        wrl::ComPtr<ID3D11PixelShader> m_ps;
        wrl::ComPtr<ID3D11InputLayout> m_il;
        wrl::ComPtr<ID3D11RasterizerState> m_rs;
        wrl::ComPtr<ID3D11SamplerState> m_texture_ss;
        wrl::ComPtr<ID3D11Buffer> m_cb_scene;
        wrl::ComPtr<ID3D11Buffer> m_cb_object;
        wrl::ComPtr<ID3D11Buffer> m_sb_point_lights;
        wrl::ComPtr<ID3D11ShaderResourceView> m_srv_point_lights;
        wrl::ComPtr<ID3D11Buffer> m_sb_spot_lights;
        wrl::ComPtr<ID3D11ShaderResourceView> m_srv_spot_lights;
    };
    OpaquePass::OpaquePass(ID3D11Device* dev, ID3D11DeviceContext* ctx, const std::vector<Mesh>& meshes, const std::vector<Texture>& textures)
        : m_dev{ dev }
        , m_ctx{ ctx }
        , m_meshes{ meshes }
        , m_textures{ textures }
        , m_viewport{ .TopLeftX = 0.0f, .TopLeftY = 0.0f, .MinDepth = 0.0f, .MaxDepth = 1.0f }
        , m_vs{}
        , m_ps{}
        , m_il{}
        , m_rs{}
        , m_cb_scene{}
        , m_cb_object{}
        , m_sb_point_lights{}
        , m_srv_point_lights{}
        , m_sb_spot_lights{}
        , m_srv_spot_lights{}
    {
        #include <qk/hlsl/OpaquePassVS.h>
        #include <qk/hlsl/OpaquePassPS.h>

        // vertex shader
        qk_CheckHR(m_dev->CreateVertexShader(OpaquePassVS_bytes, sizeof(OpaquePassVS_bytes), nullptr, m_vs.ReleaseAndGetAddressOf()));

        // pixel shader
        qk_CheckHR(m_dev->CreatePixelShader(OpaquePassPS_bytes, sizeof(OpaquePassPS_bytes), nullptr, m_ps.ReleaseAndGetAddressOf()));

        // input layout
        {
            D3D11_INPUT_ELEMENT_DESC desc[] =
            {
                { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
                { "NORMAL",   0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
                { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,    0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
            };
            qk_CheckHR(m_dev->CreateInputLayout(desc, std::size(desc), OpaquePassVS_bytes, sizeof(OpaquePassVS_bytes), m_il.ReleaseAndGetAddressOf()));
        }

        // rasterizer state
        {
            D3D11_RASTERIZER_DESC desc{};
            desc.FillMode = D3D11_FILL_SOLID;
            desc.CullMode = D3D11_CULL_BACK;
            desc.FrontCounterClockwise = true;
            desc.DepthBias = 0;
            desc.DepthBiasClamp = 0.0f;
            desc.SlopeScaledDepthBias = 0.0f;
            desc.DepthClipEnable = true;
            desc.ScissorEnable = false;
            desc.MultisampleEnable = false;
            desc.AntialiasedLineEnable = false;
            qk_CheckHR(m_dev->CreateRasterizerState(&desc, m_rs.ReleaseAndGetAddressOf()));
        }

        // sampler state
        {
            D3D11_SAMPLER_DESC desc{};
            desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
            desc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
            desc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
            desc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
            //desc.MaxAnisotropy = ;
            desc.BorderColor[0] = 0.0f;
            desc.BorderColor[1] = 0.0f;
            desc.BorderColor[2] = 0.0f;
            desc.BorderColor[3] = 0.0f;
            desc.MinLOD = 0;
            desc.MaxLOD = D3D11_FLOAT32_MAX;
            qk_CheckHR(m_dev->CreateSamplerState(&desc, m_texture_ss.ReleaseAndGetAddressOf()));
        }

        // scene constant buffer
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = sizeof(OpaquePassSceneConstants);
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            qk_CheckHR(m_dev->CreateBuffer(&desc, nullptr, m_cb_scene.ReleaseAndGetAddressOf()));
        }

        // object constant buffer
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = sizeof(OpaquePassObjectConstants);
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            qk_CheckHR(m_dev->CreateBuffer(&desc, nullptr, m_cb_object.ReleaseAndGetAddressOf()));
        }
    }
    void OpaquePass::Render(int w, int h, ID3D11RenderTargetView* rtv, ID3D11DepthStencilView* dsv, const Scene& scene)
    {
        // resize point lights structured buffer if necessary
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = 0;
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
            desc.StructureByteStride = sizeof(OpaquePassPointLight);

            if (m_sb_point_lights)
            {
                m_sb_point_lights->GetDesc(&desc);
            }

            UINT expected_size_in_bytes{ static_cast<UINT>(scene.point_lights.size() * sizeof(OpaquePassPointLight)) };
            if (desc.ByteWidth != expected_size_in_bytes)
            {
                desc.ByteWidth = expected_size_in_bytes;

                // buffer
                qk_CheckHR(m_dev->CreateBuffer(&desc, nullptr, m_sb_point_lights.ReleaseAndGetAddressOf()));
                // srv
                qk_CheckHR(m_dev->CreateShaderResourceView(m_sb_point_lights.Get(), nullptr, m_srv_point_lights.ReleaseAndGetAddressOf()));
            }
        }

        // resize spot lights structured buffer if necessary
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = 0;
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED;
            desc.StructureByteStride = sizeof(OpaquePassSpotLight);

            if (m_sb_spot_lights)
            {
                m_sb_spot_lights->GetDesc(&desc);
            }

            UINT expected_size_in_bytes{ static_cast<UINT>(scene.spot_lights.size() * sizeof(OpaquePassSpotLight)) };
            if (desc.ByteWidth != expected_size_in_bytes)
            {
                desc.ByteWidth = expected_size_in_bytes;

                // buffer
                qk_CheckHR(m_dev->CreateBuffer(&desc, nullptr, m_sb_spot_lights.ReleaseAndGetAddressOf()));
                // srv
                qk_CheckHR(m_dev->CreateShaderResourceView(m_sb_spot_lights.Get(), nullptr, m_srv_spot_lights.ReleaseAndGetAddressOf()));
            }
        }

        // set new viewport data
        m_viewport.Width = static_cast<float>(w);
        m_viewport.Height = static_cast<float>(h);

        // prepare pipeline for drawing
        {
            ID3D11Buffer* cbufs[]{ m_cb_scene.Get(), m_cb_object.Get() };

            m_ctx->ClearState();
            m_ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
            m_ctx->IASetInputLayout(m_il.Get());
            m_ctx->VSSetShader(m_vs.Get(), nullptr, 0);
            m_ctx->VSSetConstantBuffers(0, std::size(cbufs), cbufs);
            m_ctx->PSSetShader(m_ps.Get(), nullptr, 0);
            m_ctx->PSSetConstantBuffers(0, std::size(cbufs), cbufs);
            m_ctx->RSSetState(m_rs.Get());
            m_ctx->RSSetViewports(1, &m_viewport);
            m_ctx->OMSetRenderTargets(1, &rtv, dsv);
        }

        // upload scene constants
        {
            float aspect{ m_viewport.Width / m_viewport.Height };
            float fov_rad{ DirectX::XMConvertToRadians(scene.camera.fov_deg) };
            Matrix view{ Matrix::CreateLookAt(Vector3{ scene.camera.eye.elems }, Vector3{ scene.camera.target.elems }, Vector3{ scene.camera.up.elems }) };
            Matrix projection{ Matrix::CreatePerspectiveFieldOfView(fov_rad, aspect, scene.camera.near_plane, scene.camera.far_plane) };

            d11::SubresourceMap map{ m_ctx, m_cb_scene.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
            auto constants{ static_cast<OpaquePassSceneConstants*>(map.Data()) };
            constants->view = view;
            constants->projection = projection;
            constants->point_lights_count = static_cast<std::int32_t>(scene.point_lights.size());
            constants->spot_lights_count = static_cast<std::int32_t>(scene.spot_lights.size());
        }

        // upload point lights
        if (m_sb_point_lights)
        {
            d11::SubresourceMap map{ m_ctx, m_sb_point_lights.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
            auto constants{ static_cast<OpaquePassPointLight*>(map.Data()) };

            for (std::size_t i{}; i < scene.point_lights.size(); i++)
            {
                const PointLight& point_light{ scene.point_lights[i] };

                constants[i].world_position = Vector3{ point_light.position.elems };
                constants[i].color = Vector3{ point_light.color.elems };
                constants[i].r_min = point_light.r_min;
                constants[i].r_max = point_light.r_max;
            }
        }

        // upload spot lights
        if (m_sb_spot_lights)
        {
            d11::SubresourceMap map{ m_ctx, m_sb_spot_lights.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
            auto constants{ static_cast<OpaquePassSpotLight*>(map.Data()) };

            for (std::size_t i{}; i < scene.spot_lights.size(); i++)
            {
                const SpotLight& spot_light{ scene.spot_lights[i] };

                constants[i].world_position = Vector3{ spot_light.position.elems };
                constants[i].direction = Vector3{ spot_light.direction.elems };
                constants[i].color = Vector3{ spot_light.color.elems };
                constants[i].r_min = spot_light.r_min;
                constants[i].r_max = spot_light.r_max;
                constants[i].umbra_rad = dx::XMConvertToRadians(spot_light.umbra_angle_deg);
                constants[i].penumbra_rad = dx::XMConvertToRadians(spot_light.penumbra_angle_deg);
            }
        }

        // loop over each object node and render it
        for (const Object& object : scene.objects)
        {
            // compute object's model and normal matrices, then upload them to the GPU
            {
                Vector3 rotation_rad{};
                rotation_rad.x = DirectX::XMConvertToRadians(object.rotation.x());
                rotation_rad.y = DirectX::XMConvertToRadians(object.rotation.y());
                rotation_rad.z = DirectX::XMConvertToRadians(object.rotation.z());

                Matrix translate{ Matrix::CreateTranslation(Vector3{ object.position.elems }) };
                Matrix rotate{ Matrix::CreateFromYawPitchRoll(rotation_rad) };
                Matrix scale{ Matrix::CreateScale(Vector3{ object.scaling.elems }) };
                Matrix model{ scale * rotate * translate };
                Matrix normal{ scale * rotate };
                normal.Invert();
                normal.Transpose();

                d11::SubresourceMap map{ m_ctx, m_cb_object.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
                auto constants{ static_cast<OpaquePassObjectConstants*>(map.Data()) };
                constants->model = model;
                constants->normal = normal;
                constants->albedo_color = Vector3{ object.albedo_color.elems };
                constants->albedo_mix = object.albedo_mix;
                constants->directional_light.direction = Vector3{ scene.directional_light.direction.elems };
                constants->directional_light.color = Vector3{ scene.directional_light.color.elems };
            }

            // set mesh related pipeline state and submit draw call
            {
                // fetch mesh
                const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(object.mesh_id)) };

                // fetch albedo
                const Texture& albedo{ m_textures.at(static_cast<std::size_t>(object.albedo_id)) };

                // prepare mesh related data for pipeline state
                ID3D11Buffer* vertices{ mesh.Vertices() };
                UINT vertex_stride{ sizeof(MeshVertex) };
                UINT vertex_offset{};

                // prepare texture related data for pipeline state
                ID3D11SamplerState* sss[]{ m_texture_ss.Get() };
                ID3D11ShaderResourceView* srvs[]{ albedo.SRV(), m_srv_point_lights.Get(), m_srv_spot_lights.Get() };

                // set pipeline state
                m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                m_ctx->PSSetSamplers(0, std::size(sss), sss);
                m_ctx->PSSetShaderResources(0, std::size(srvs), srvs);

                // draw
                m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
            }
        }
    }

    class GizmoPass
    {
    public:
        GizmoPass(ID3D11Device* dev, ID3D11DeviceContext* ctx, const std::vector<Mesh>& meshes);
        ~GizmoPass() = default;
        GizmoPass(const GizmoPass&) = delete;
        GizmoPass(GizmoPass&&) noexcept = delete;
        GizmoPass& operator=(const GizmoPass&) = delete;
        GizmoPass& operator=(GizmoPass&&) noexcept = delete;
    public:
        void Render(int w, int h, ID3D11RenderTargetView* rtv, ID3D11DepthStencilView* dsv, const Scene& scene);
    private:
        ID3D11Device* m_dev;
        ID3D11DeviceContext* m_ctx;
        const std::vector<Mesh>& m_meshes;
        D3D11_VIEWPORT m_viewport;
        wrl::ComPtr<ID3D11VertexShader> m_vs;
        wrl::ComPtr<ID3D11PixelShader> m_ps;
        wrl::ComPtr<ID3D11InputLayout> m_il;
        wrl::ComPtr<ID3D11RasterizerState> m_rs_fill;
        wrl::ComPtr<ID3D11RasterizerState> m_rs_wireframe;
        wrl::ComPtr<ID3D11Buffer> m_cb_scene;
        wrl::ComPtr<ID3D11Buffer> m_cb_object;
    };
    GizmoPass::GizmoPass(ID3D11Device* dev, ID3D11DeviceContext* ctx, const std::vector<Mesh>& meshes)
        : m_dev{ dev }
        , m_ctx{ ctx }
        , m_meshes{ meshes }
        , m_viewport{ .TopLeftX = 0.0f, .TopLeftY = 0.0f, .MinDepth = 0.0f, .MaxDepth = 1.0f }
        , m_vs{}
        , m_ps{}
        , m_il{}
        , m_rs_fill{}
        , m_rs_wireframe{}
        , m_cb_scene{}
        , m_cb_object{}
    {
        #include <qk/hlsl/GizmoPassVS.h>
        #include <qk/hlsl/GizmoPassPS.h>

        // vertex shader
        qk_CheckHR(m_dev->CreateVertexShader(GizmoPassVS_bytes, sizeof(GizmoPassVS_bytes), nullptr, m_vs.ReleaseAndGetAddressOf()));

        // pixel shader
        qk_CheckHR(m_dev->CreatePixelShader(GizmoPassPS_bytes, sizeof(GizmoPassPS_bytes), nullptr, m_ps.ReleaseAndGetAddressOf()));

        // input layout
        {
            D3D11_INPUT_ELEMENT_DESC desc[] =
            {
                { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0 },
            };
            qk_CheckHR(m_dev->CreateInputLayout(desc, std::size(desc), GizmoPassVS_bytes, sizeof(GizmoPassVS_bytes), m_il.ReleaseAndGetAddressOf()));
        }

        // fill rasterizer state
        {
            D3D11_RASTERIZER_DESC desc{};
            desc.FillMode = D3D11_FILL_SOLID;
            desc.CullMode = D3D11_CULL_BACK;
            desc.FrontCounterClockwise = true;
            desc.DepthBias = 0;
            desc.DepthBiasClamp = 0.0f;
            desc.SlopeScaledDepthBias = 0.0f;
            desc.DepthClipEnable = true;
            desc.ScissorEnable = false;
            desc.MultisampleEnable = false;
            desc.AntialiasedLineEnable = false;
            qk_CheckHR(m_dev->CreateRasterizerState(&desc, m_rs_fill.ReleaseAndGetAddressOf()));
        }

        // wireframe rasterizer state
        {
            D3D11_RASTERIZER_DESC desc{};
            desc.FillMode = D3D11_FILL_WIREFRAME;
            desc.CullMode = D3D11_CULL_NONE;
            desc.FrontCounterClockwise = true;
            desc.DepthBias = 0;
            desc.DepthBiasClamp = 0.0f;
            desc.SlopeScaledDepthBias = 0.0f;
            desc.DepthClipEnable = true;
            desc.ScissorEnable = false;
            desc.MultisampleEnable = false;
            desc.AntialiasedLineEnable = false;
            qk_CheckHR(m_dev->CreateRasterizerState(&desc, m_rs_wireframe.ReleaseAndGetAddressOf()));
        }

        // scene constant buffer
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = sizeof(GizmoPassSceneConstants);
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            qk_CheckHR(m_dev->CreateBuffer(&desc, nullptr, m_cb_scene.ReleaseAndGetAddressOf()));
        }

        // object constant buffer
        {
            D3D11_BUFFER_DESC desc{};
            desc.ByteWidth = sizeof(GizmoPassObjectConstants);
            desc.Usage = D3D11_USAGE_DYNAMIC;
            desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
            desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
            desc.MiscFlags = 0;
            desc.StructureByteStride = 0;
            qk_CheckHR(m_dev->CreateBuffer(&desc, nullptr, m_cb_object.ReleaseAndGetAddressOf()));
        }
    }
    void GizmoPass::Render(int w, int h, ID3D11RenderTargetView* rtv, ID3D11DepthStencilView* dsv, const Scene& scene)
    {
        // set new viewport data
        m_viewport.Width = static_cast<float>(w);
        m_viewport.Height = static_cast<float>(h);

        // prepare pipeline for drawing
        {
            ID3D11Buffer* cbufs[]{ m_cb_scene.Get(), m_cb_object.Get() };

            m_ctx->ClearState();
            m_ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
            m_ctx->IASetInputLayout(m_il.Get());
            m_ctx->VSSetShader(m_vs.Get(), nullptr, 0);
            m_ctx->VSSetConstantBuffers(0, std::size(cbufs), cbufs);
            m_ctx->PSSetShader(m_ps.Get(), nullptr, 0);
            m_ctx->PSSetConstantBuffers(0, std::size(cbufs), cbufs);
            m_ctx->RSSetViewports(1, &m_viewport);
            m_ctx->OMSetRenderTargets(1, &rtv, dsv);
        }

        // upload scene constants
        {
            float aspect{ m_viewport.Width / m_viewport.Height };
            float fov_rad{ DirectX::XMConvertToRadians(scene.camera.fov_deg) };
            Matrix view{ Matrix::CreateLookAt(Vector3{ scene.camera.eye.elems }, Vector3{ scene.camera.target.elems }, Vector3{ scene.camera.up.elems }) };
            Matrix projection{ Matrix::CreatePerspectiveFieldOfView(fov_rad, aspect, scene.camera.near_plane, scene.camera.far_plane) };

            d11::SubresourceMap map{ m_ctx, m_cb_scene.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
            auto constants{ static_cast<GizmoPassSceneConstants*>(map.Data()) };
            constants->view = view;
            constants->projection = projection;
        }

        // render point lights
        {
            // use icosphere mesh as point light gizmo
            const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(ICOSPHERE)) };

            // set point light related pipeline state 
            {
                // prepare mesh related data for pipeline state
                ID3D11Buffer* vertices{ mesh.Vertices() };
                UINT vertex_stride{ sizeof(MeshVertex) };
                UINT vertex_offset{};

                // set pipeline state
                m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                m_ctx->RSSetState(m_rs_wireframe.Get());
            }

            for (const PointLight& point_light : scene.point_lights)
            {
                // upload light source object constants
                {
                    float diameter{ point_light.r_min * 2.0f };

                    Matrix translate{ Matrix::CreateTranslation(Vector3{ point_light.position.elems }) };
                    Matrix scale{ Matrix::CreateScale(Vector3{ diameter, diameter, diameter }) };
                    Matrix model{ scale * translate };

                    d11::SubresourceMap map{ m_ctx, m_cb_object.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
                    auto constants{ static_cast<GizmoPassObjectConstants*>(map.Data()) };
                    constants->model = model;
                    constants->color = Vector3{ point_light.color.elems };
                }

                // draw light source gizmo
                m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);

                // upload light volume object constants
                {
                    float diameter{ point_light.r_max * 2.0f };

                    Matrix translate{ Matrix::CreateTranslation(Vector3{ point_light.position.elems }) };
                    Matrix scale{ Matrix::CreateScale(Vector3{ diameter, diameter, diameter }) };
                    Matrix model{ scale * translate };

                    d11::SubresourceMap map{ m_ctx, m_cb_object.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
                    auto constants{ static_cast<GizmoPassObjectConstants*>(map.Data()) };
                    constants->model = model;
                    constants->color = Vector3{ point_light.color.elems };
                }

                // draw light source gizmo
                m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
            }
        }

        // render spot lights
        {
            // use cone mesh as spot light gizmo
            const Mesh& mesh{ m_meshes.at(static_cast<std::size_t>(CONE_NO_BASE)) };

            // set spot light related pipeline state 
            {
                // prepare mesh related data for pipeline state
                ID3D11Buffer* vertices{ mesh.Vertices() };
                UINT vertex_stride{ sizeof(MeshVertex) };
                UINT vertex_offset{};

                // set pipeline state
                m_ctx->IASetIndexBuffer(mesh.Indices(), MESH_INDEX_FORMAT, 0);
                m_ctx->IASetVertexBuffers(0, 1, &vertices, &vertex_stride, &vertex_offset);
                m_ctx->RSSetState(m_rs_wireframe.Get());
            }

            for (const SpotLight& spot_light : scene.spot_lights)
            {
                // for each spot light we render three cones: umbra, penumbra and near
                constexpr int COUNT{ 3 };

                // cones angles
                // TODO: if we draw both umbra and penumbra cones, use the umbra cone angle as the near cone angle, 
                // TODO: if we draw just one of the two cones, use as near cone angle the angle of the cone we are drawing
                float angles_deg[COUNT]{ spot_light.umbra_angle_deg, spot_light.penumbra_angle_deg, spot_light.umbra_angle_deg };

                // convert umbra and penumbra angles to radians
                float angles_rad[COUNT]{};
                for (int i{}; i < COUNT; i++)
                {
                    angles_rad[i] = dx::XMConvertToRadians(angles_deg[i]);
                }

                // y scaling factors for each cone
                float y_scales[COUNT]{ spot_light.r_max, spot_light.r_max, spot_light.r_min };

                // compute x and z scaling factors for each cone
                float xz_scales[COUNT]{};
                for (int i{}; i < COUNT; i++)
                {
                    xz_scales[i] = 2.0f * y_scales[i] * std::tan(angles_rad[i]);
                }

                // render umbra and penumbra light volumes
                for (int i{}; i < COUNT; i++)
                {
                    // upload light volume object constants
                    {
                        // move cone local space origin to cone peak
                        Matrix translate_0{ Matrix::CreateTranslation(Vector3{ 0.0f, -0.5f, 0.0f }) };
                        // translate cone peak to specified position
                        Matrix translate_1{ Matrix::CreateTranslation(Vector3{ spot_light.position.elems }) };
                        Matrix rotate{};
                        {
                            Vector3 direction{ spot_light.direction.elems };
                            direction.Normalize();
                            Vector3 down{ 0.0f, -1.0f, 0.0f }; // local space cone's direction 

                            // check wheter direction and down have the same direction
                            float dot{ direction.Dot(down) };
                            if (dot == 1.0f) // they do; no need to rotate
                            {
                                // do nothing
                            }
                            else // they don't 
                            {
                                // compute rotation axis for rotating down into direction
                                Vector3 axis{};
                                if (dot == -1.0f) // direction and down have opposite directions; corss won't work
                                {
                                    // as rotation axis we pick any vector orthogonal to direction
                                    if (direction.x == 0.0f)
                                    {
                                        axis.y = -direction.z;
                                        axis.z = direction.y;
                                    }
                                    else if (direction.y == 0.0f)
                                    {
                                        axis.x = -direction.z;
                                        axis.z = direction.x;
                                    }
                                    else
                                    {
                                        axis.x = -direction.y;
                                        axis.y = direction.x;
                                    }
                                }
                                else // cross will work
                                {
                                    axis = down.Cross(direction);
                                }

                                // compute rotation angle for rotating down into direction
                                float angle{ std::acos(dot) };

                                // compute rotation matrix
                                rotate = Matrix::CreateFromAxisAngle(axis, angle);
                            }
                        }
                        Matrix scale{ Matrix::CreateScale(Vector3{ xz_scales[i], y_scales[i], xz_scales[i]}) };
                        Matrix model{ translate_0 * scale * rotate * translate_1 };

                        d11::SubresourceMap map{ m_ctx, m_cb_object.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0 };
                        auto constants{ static_cast<GizmoPassObjectConstants*>(map.Data()) };
                        constants->model = model;
                        constants->color = Vector3{ spot_light.color.elems };
                    }

                    // draw gizmo
                    m_ctx->DrawIndexed(mesh.IndexCount(), 0, 0);
                }
            }
        }
    }

    class RendererImpl
    {
    public:
        RendererImpl(ID3D11Device* dev, ID3D11DeviceContext* ctx);
        ~RendererImpl() = default;
        RendererImpl(const RendererImpl&) = delete;
        RendererImpl(RendererImpl&&) noexcept = delete;
        RendererImpl& operator=(const RendererImpl&) = delete;
        RendererImpl& operator=(RendererImpl&&) noexcept = delete;
    public:
        void Render(int w, int h, ID3D11RenderTargetView* rtv, const Scene& scene);
    private:
        ID3D11Device* m_dev;
        ID3D11DeviceContext* m_ctx;
        std::vector<Mesh> m_meshes;
        std::vector<Texture> m_textures;
        wrl::ComPtr<ID3D11Texture2D> m_depth_stencil_buffer;
        wrl::ComPtr<ID3D11DepthStencilView> m_dsv;
        OpaquePass m_opaque_pass;
        GizmoPass m_gizmo_pass;
    };

    RendererImpl::RendererImpl(ID3D11Device* dev, ID3D11DeviceContext* ctx)
        : m_dev{ dev }
        , m_ctx{ ctx }
        , m_meshes{}
        , m_textures{}
        , m_depth_stencil_buffer{}
        , m_dsv{}
        , m_opaque_pass{ m_dev, m_ctx, m_meshes, m_textures }
        , m_gizmo_pass{ m_dev, m_ctx, m_meshes }
    {
        // upload default meshes
        {
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Cube(m_dev));
                qk_Check(MeshID{ idx } == CUBE); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Quad(m_dev));
                qk_Check(MeshID{ idx } == QUAD); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Icosphere(m_dev));
                qk_Check(MeshID{ idx } == ICOSPHERE); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::Cone(m_dev));
                qk_Check(MeshID{ idx } == CONE); // check that the mesh index matches its predefined id
            }
            {
                size_t idx{ m_meshes.size() };
                m_meshes.emplace_back(Mesh::ConeNoBase(m_dev));
                qk_Check(MeshID{ idx } == CONE_NO_BASE); // check that the mesh index matches its predefined id
            }
        }
        // upload ddefault textures
        {
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoBlack(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_BLACK); // check that the texture index matches its predefined id
            }
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoWhite(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_WHITE); // check that the texture index matches its predefined id
            }
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoPink(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_PINK); // check that the texture index matches its predefined id
            }
            {
                size_t idx{ m_textures.size() };
                m_textures.emplace_back(Texture::AlbedoChecker(m_dev));
                qk_Check(TextureID{ idx } == ALBEDO_CHECKER); // check that the texture index matches its predefined id
            }
        }
    }
    void RendererImpl::Render(int w, int h, ID3D11RenderTargetView* rtv, const Scene& scene)
    {
        // resize depth buffer if w or h changed
        {
            D3D11_TEXTURE2D_DESC desc{};
            desc.Width = 0;
            desc.Height = 0;
            desc.MipLevels = 1;
            desc.ArraySize = 1;
            desc.Format = DXGI_FORMAT_D32_FLOAT;
            desc.SampleDesc = { .Count = 1, .Quality = 0 };
            desc.Usage = D3D11_USAGE_DEFAULT;
            desc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
            desc.CPUAccessFlags = 0;
            desc.MiscFlags = 0;

            if (m_depth_stencil_buffer)
            {
                m_depth_stencil_buffer->GetDesc(&desc);
            }

            if (desc.Width != static_cast<UINT>(w) || desc.Height != static_cast<UINT>(h))
            {
                desc.Width = static_cast<UINT>(w);
                desc.Height = static_cast<UINT>(h);

                // depth stencil buffer
                qk_CheckHR(m_dev->CreateTexture2D(&desc, nullptr, m_depth_stencil_buffer.ReleaseAndGetAddressOf()));
                // depth stencil view
                qk_CheckHR(m_dev->CreateDepthStencilView(m_depth_stencil_buffer.Get(), nullptr, m_dsv.ReleaseAndGetAddressOf()));
            }
        }

        // clear rtv using the specified background
        m_ctx->ClearRenderTargetView(rtv, scene.background.color.elems);

        // clear dsv
        m_ctx->ClearDepthStencilView(m_dsv.Get(), D3D11_CLEAR_DEPTH, 1.0f, 0);

        // run render passes
        m_opaque_pass.Render(w, h, rtv, m_dsv.Get(), scene);
        m_gizmo_pass.Render(w, h, rtv, m_dsv.Get(), scene);
    }

    Renderer::Renderer(void* d3d_dev, void* d3d_ctx)
        : m_impl{ std::make_shared<RendererImpl>(static_cast<ID3D11Device*>(d3d_dev), static_cast<ID3D11DeviceContext*>(d3d_ctx)) }
    {
    }
    void Renderer::Render(int w, int h, void* rtv, const Scene& scene)
    {
        std::static_pointer_cast<RendererImpl>(m_impl)->Render(w, h, static_cast<ID3D11RenderTargetView*>(rtv), scene);
    }
}
